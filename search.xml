<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Kotlin协程Api用例详解</title>
      <link href="/2018/04/26/kotlin-coroutines/"/>
      <url>/2018/04/26/kotlin-coroutines/</url>
      <content type="html"><![CDATA[<h3 id="Kotlin协程简述"><a href="#Kotlin协程简述" class="headerlink" title="Kotlin协程简述"></a>Kotlin协程简述</h3><p>开发中许多任务是需要长时间运行，并且需要调用者阻塞直到这些调用完成（比如网络 IO ，文件 IO ，CPU 或者 GPU 比较集中的工作）。协程提供了一种避免线程阻塞并且用一种更轻量级，更易操控到操作：协程暂停。</p><pre><code>//添加Kotlin协程依赖implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:0.22.5&quot;</code></pre><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>当一个函数被 suspend 修饰时表示可以被挂起，调用它会导致挂起协程，挂起函数可以和正常函数那样接受参数返回结果，但只能在协程中调用或着被其他挂起函数调用。</p><pre><code>suspend fun doSomething(){        //do something        delay(1000)    }</code></pre><p>因为delay为Kotlin封装的挂起函数，所以调用delay的函数也必须是挂起函数。</p><h3 id="协程Api"><a href="#协程Api" class="headerlink" title="协程Api"></a>协程Api</h3><p>在已有的Api中，Kotlin提供了两种方式实现协程 async/Deferred和launch/Job</p><pre><code>//async/Deferredpublic actual fun &lt;T&gt; async(    context: CoroutineContext = DefaultDispatcher,    start: CoroutineStart = CoroutineStart.DEFAULT,    parent: Job? = null,   &lt;strong&gt; block: suspend CoroutineScope.() -&gt; T&lt;/strong&gt;): Deferred&lt;T&gt; {    val newContext = newCoroutineContext(context, parent)    val coroutine = if (start.isLazy)        LazyDeferredCoroutine(newContext, block) else        DeferredCoroutine&lt;T&gt;(newContext, active = true)    coroutine.start(start, coroutine, block)    return coroutine}</code></pre><pre><code>//launch/Jobpublic expect fun launch(    context: CoroutineContext = DefaultDispatcher,    start: CoroutineStart = CoroutineStart.DEFAULT,    parent: Job? = null,   &lt;strong&gt; block: suspend CoroutineScope.() -&gt; Unit&lt;/strong&gt;): Job</code></pre><p>从源码中可以看出async和launch的参数列表中只有最后一个参数：带有 suspend 修饰的函数类型不同，async中的lambda有返回值，和Deferred的类型相同。launch中的lambda没有返回值。</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>两个Api的构造函数中，第一个参数为context。在android开发中比较常用的两个为UI何CommonPool。<br>UI为主线程，UI线程，只有context是UI的launch或者async的block lambda中才能更新UI<br>CommonPool为公共的线程池，在context是CommonPool的lauch或者async中的block lambda中可以异步处理耗时操作。</p><pre><code>launch(UI) {            text.setText(&quot;UI&quot;)        }async(UI) {            text.setText(&quot;UI&quot;)        }launch(CommonPool) {            delay(1000)        }async(CommonPool) {            delay(1000)        }</code></pre><h4 id="async-Deferred"><a href="#async-Deferred" class="headerlink" title="async/Deferred"></a>async/Deferred</h4><pre><code> async{            loge(message = &quot;outer start&quot;)            val inner = async{                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)                &quot;stop&quot;            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            val await = inner.await()            loge(message = &quot;outer stop&quot;)            await        }//        依次打印//        16:30:41.759 14668-14737/com.moo.demogo E/DemoGo: outer start//        16:30:41.761 14668-14737/com.moo.demogo E/DemoGo: outer wait itself start//        16:30:41.768 14668-14737/com.moo.demogo E/DemoGo: inner start//        16:30:42.268 14668-14738/com.moo.demogo E/DemoGo: outer wait itself stop//        16:30:42.268 14668-14738/com.moo.demogo E/DemoGo: outer wait inner//        16:30:42.771 14668-14738/com.moo.demogo E/DemoGo: inner stop//        16:30:42.772 14668-14738/com.moo.demogo E/DemoGo: outer stop</code></pre><p>从打印的信息可以看出outer（外层async）开始线性调用，打印outer start，在inner创建之后inner也开始执行，（outer wait itself start打印在inner start之前是因为inner async在创建的过程中会耗费极少的时间，而在这段时间内outer已经执行到下一步，理论上在inner创建之后，inner和outer之后都是同步执行）当outer等待500ms之后 outer打印outer wait itself stop同时开始等待inner，打印outer wait inner，下面这句代码val await = inner.await()为Kotlin协程重点。正常情况下，outer会直接打印outer stop，之后等待500ms之后 inner stop。但是由于inner.await(),outer会挂起，等待inner执行结束，返回字符串“stop”之后，outer再结束，这也就是为什么最后是outer wait inner500ms之后inner stop 然后才是outer stop</p><h4 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch/Job"></a>launch/Job</h4><pre><code>launch{            loge(message = &quot;outer start&quot;)            val inner = launch{                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            inner.join()            loge(message = &quot;outer stop&quot;)        }//        依次打印//        16:57:05.431 20131-20298/com.moo.demogo E/DemoGo: outer start//        16:57:05.432 20131-20298/com.moo.demogo E/DemoGo: outer wait itself start//        16:57:05.432 20131-20300/com.moo.demogo E/DemoGo: inner start//        16:57:05.940 20131-20298/com.moo.demogo E/DemoGo: outer wait itself stop//        16:57:05.940 20131-20298/com.moo.demogo E/DemoGo: outer wait inner//        16:57:06.439 20131-20298/com.moo.demogo E/DemoGo: inner stop//        16:57:06.441 20131-20300/com.moo.demogo E/DemoGo: outer stop</code></pre><p>打印信息和async/Deferred一致，区别在与lauch返回Job，挂起方法为job.join()且没有返回值。</p><p>async和launch可以根据是否需要返回值这一特点选择使用或者混合使用</p><pre><code>launch {            loge(message = &quot;outer start&quot;)            val inner = async {                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)                &quot;stop&quot;            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            val await = inner.await()            //deal result await            loge(message = &quot;outer stop&quot;)        }</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>源码分析SwipeRefreshLayout子View侧滑冲突（侧滑菜单ListView，ViewPager）</title>
      <link href="/2018/04/25/tips-swiperefreshlayout/"/>
      <url>/2018/04/25/tips-swiperefreshlayout/</url>
      <content type="html"><![CDATA[<p>先上干货，侧滑菜单listview和去除冲突的SwipeRefreshLayout  <a href="https://github.com/little-tongue/SidesplidListView" target="_blank" rel="noopener">github项目地址</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间项目需要侧滑菜单的ListView，所以自己重写ListView仿qq的部分效果自定义了一个SideslipListView，在Dome里面运行正常，但是在使用的时候，发现经常侧滑有时候滑一半就失灵了，并且同时触发了SwipeRefreshLayout的下拉刷新CircleImageView的显示。反复试验了几次并配合log，得出问题：<strong>当SideslipListView到了顶部且侧滑的时候出现垂直方向滑动，会导致子View的滑动事件失效，SwipeRefreshLayout处理了滑动事件，显示顶部CircleImageView。</strong>因为我的SideslipListView是通过对触摸事件做处理实现侧滑的，所以我第一反应就是可能滑动冲突了。</p><h3 id="Android事件分发"><a href="#Android事件分发" class="headerlink" title="Android事件分发"></a>Android事件分发</h3><p><div align="center"><img src="https://img-blog.csdn.net/20180411112342276"></div><br>上面这张图相信所有人都烂熟于心了，简单分析可以知道SwipeRefreshLayout可能搞事情的地方是<strong>dispatchTouchEvent ，onInterceptTouchEvent</strong>。那就去看看源码中是如何实现。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>SwipeRefreshLayout继承自ViewGroup，在SwipeRefreshLayout中没有重写dispatchTouchEvent，只重写了 onInterceptTouchEvent，所以只用看在onInterceptTouchEvent中怎么处理的。<br><pre><code>@Override   public boolean onInterceptTouchEvent(MotionEvent ev) {       ensureTarget();       final int action = ev.getActionMasked();       int pointerIndex;       if (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) {           mReturningToStart = false;       }       if (!isEnabled() || mReturningToStart || canChildScrollUp()               || mRefreshing || mNestedScrollInProgress) {           &#x2F;&#x2F; Fail fast if we&#39;re not in a state where a swipe is possible           return false;       }       switch (action) {           case MotionEvent.ACTION_DOWN:               setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCircleView.getTop());               mActivePointerId = ev.getPointerId(0);               mIsBeingDragged = false;               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               mInitialDownY = ev.getY(pointerIndex);               break;           case MotionEvent.ACTION_MOVE:               if (mActivePointerId == INVALID_POINTER) {                   Log.e(LOG_TAG, &quot;Got ACTION_MOVE event but don&#39;t have an active pointer id.&quot;);                   return false;               }               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               final float y = ev.getY(pointerIndex);               startDragging(y);               break;           case MotionEvent.ACTION_POINTER_UP:               onSecondaryPointerUp(ev);               break;           case MotionEvent.ACTION_UP:           case MotionEvent.ACTION_CANCEL:               mIsBeingDragged = false;               mActivePointerId = INVALID_POINTER;               break;       }       return mIsBeingDragged;   }</code></pre><br>可以看到最终返回的是mIsBeingDragged的值，mIsBeingDragged表示SwipeRefreshLayout是否开始下拉刷新的操作，即SwipeRefreshLayout顶部的CircleImageView是否开始显示。mIsBeingDragged的值是true时，就会导致SwipeRefreshLayout的子View不能接受到相应的事件。</p><p>在分Action处理事件之前有一段代码</p><pre><code>if (!isEnabled() || mReturningToStart || canChildScrollUp()                || mRefreshing || mNestedScrollInProgress) {            // Fail fast if we&#39;re not in a state where a swipe is possible            return false;        }</code></pre><p>这段代码在SwipeRefreshLayout不可用，或者SwipeRefreshLayout的子View没有滑动到了顶部(其中ListView的判断是canChildScrollUp())的时候直接返回false，不拦截子view的触摸事件。这也就是为什么最开始产生的问题中，必须是SideSlipListView滑动到顶部的时候才会产生。</p><pre><code>public boolean canChildScrollUp() {    if (mChildScrollUpCallback != null) {        return mChildScrollUpCallback.canChildScrollUp(this, mTarget);    }    if (mTarget instanceof ListView) {        return ListViewCompat.canScrollList((ListView) mTarget, -1);    }    return mTarget.canScrollVertically(-1);}</code></pre><p>ACTION_DOWN ：mIsBeingDragged的第一次赋值在ACTION_DOWN中赋值为false，ACTION_DOWN中其他的代码都是初始化一些参数，可以略过。</p><p>ACTION_MOVE:在ACTION_MOVE中获取了触摸的Y坐标，然后调用了startDrag个ing（y）,跟踪过去。</p><pre><code>private void startDragging(float y) {       final float yDiff = y - mInitialDownY;       if (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) {           mInitialMotionY = mInitialDownY + mTouchSlop;           mIsBeingDragged = true;           mProgress.setAlpha(STARTING_PROGRESS_ALPHA);       }   }</code></pre><p>这里一目了然，把当前的y坐标和ACTION_DOWN中的起始y坐标求差，当Y轴的移动距离大于系统最小滑动距离的时候，会将mIsBeingDragged从false变成true,从而使onInterceptTouchEvent返回true，拦截子View的触摸事件。所以只要我们重写SwipeRefreshLayout的onInterceptTouchEvent方法，当滑动事件可判断为水平滑动的时候直接返回false，就可以解决SwipeRefreshLayout下子View的水平滑动冲突了。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code>/** * 是否让子view处理touch事件 */private boolean letChildDealTouchEvent;private float startX;private float startY;private int mTouchSlop;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) {    switch (ev.getAction()) {        case MotionEvent.ACTION_DOWN:            // 记录手指按下的位置            startY = ev.getY();            startX = ev.getX();            // 初始化标记            letChildDealTouchEvent = false;            break;        case MotionEvent.ACTION_MOVE:            // 如果子view正在拖拽中，那么不拦截它的事件，直接return false；            if (letChildDealTouchEvent) {                return false;            }            // 获取当前手指位置            float endY = ev.getY();            float endX = ev.getX();            float distanceX = Math.abs(endX - startX);            float distanceY = Math.abs(endY - startY);            // 如果X轴位移大于Y轴位移，那么将事件交给子View处理            if (distanceX &gt; mTouchSlop &amp;&amp; distanceX &gt; distanceY) {                letChildDealTouchEvent = true;                return false;            }            break;        case MotionEvent.ACTION_UP:        case MotionEvent.ACTION_CANCEL:            // 初始化标记            letChildDealTouchEvent = false;            break;        default:            break;    }    return super.onInterceptTouchEvent(ev);}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>当SwipeRefreshLayout可用且在子view滑动到顶部的时候，会对垂直方向的滑动事件做判断，当垂直方向向下的滑动距离大于系统最小滑动距离的时候，会拦截子View的Touch事件，开始做下拉刷新处理。重写SwipeRefreshLayout的onInterceptTouchEvent事件，对水平滑动做相应处理，可以避免该问题产生。 </strong></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
