<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>源码分析SwipeRefreshLayout子View侧滑冲突（侧滑菜单ListView，ViewPager）</title>
      <link href="/2018/04/25/tips-swiperefreshlayout/"/>
      <url>/2018/04/25/tips-swiperefreshlayout/</url>
      <content type="html"><![CDATA[<p>先上干货，侧滑菜单listview和去除冲突的SwipeRefreshLayout  <a href="https://github.com/little-tongue/SidesplidListView" target="_blank" rel="noopener">github项目地址</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间项目需要侧滑菜单的ListView，所以自己重写ListView仿qq的部分效果自定义了一个SideslipListView，<br>在Dome里面运行正常，但是在使用的时候，发现经常侧滑有时候滑一半就失灵了，并且同时触发了SwipeRefreshLayout<br>的下拉刷新CircleImageView的显示。反复试验了几次并配合log，得出问题：<strong>当SideslipListView到了顶部且侧滑的时候<br>出现垂直方向滑动，会导致子View的滑动事件失效，SwipeRefreshLayout处理了滑动事件，显示顶部CircleImageView。</strong><br>因为我的SideslipListView是通过对触摸事件做处理实现侧滑的，所以我第一反应就是可能滑动冲突了。</p><h3 id="Android事件分发"><a href="#Android事件分发" class="headerlink" title="Android事件分发"></a>Android事件分发</h3><p><div align="center"><img src="https://img-blog.csdn.net/20180411112342276"></div><br>上面这张图相信所有人都烂熟于心了，简单分析可以知道SwipeRefreshLayout可能搞事情的地方是<strong>dispatchTouchEvent ，onInterceptTouchEvent</strong>。那就去看看源码中是如何实现。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>SwipeRefreshLayout继承自ViewGroup，在SwipeRefreshLayout中没有重写dispatchTouchEvent，只重写了 onInterceptTouchEvent，所以只用看在onInterceptTouchEvent中怎么处理的。<br><pre><code>@Override   public boolean onInterceptTouchEvent(MotionEvent ev) {       ensureTarget();       final int action = ev.getActionMasked();       int pointerIndex;       if (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) {           mReturningToStart = false;       }       if (!isEnabled() || mReturningToStart || canChildScrollUp()               || mRefreshing || mNestedScrollInProgress) {           &#x2F;&#x2F; Fail fast if we&#39;re not in a state where a swipe is possible           return false;       }       switch (action) {           case MotionEvent.ACTION_DOWN:               setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCircleView.getTop());               mActivePointerId = ev.getPointerId(0);               mIsBeingDragged = false;               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               mInitialDownY = ev.getY(pointerIndex);               break;           case MotionEvent.ACTION_MOVE:               if (mActivePointerId == INVALID_POINTER) {                   Log.e(LOG_TAG, &quot;Got ACTION_MOVE event but don&#39;t have an active pointer id.&quot;);                   return false;               }               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               final float y = ev.getY(pointerIndex);               startDragging(y);               break;           case MotionEvent.ACTION_POINTER_UP:               onSecondaryPointerUp(ev);               break;           case MotionEvent.ACTION_UP:           case MotionEvent.ACTION_CANCEL:               mIsBeingDragged = false;               mActivePointerId = INVALID_POINTER;               break;       }       return mIsBeingDragged;   }</code></pre><br>可以看到最终返回的是mIsBeingDragged的值，mIsBeingDragged表示SwipeRefreshLayout是否开始下拉刷新的操作，即SwipeRefreshLayout顶部的CircleImageView是否开始显示。mIsBeingDragged的值是true时，就会导致SwipeRefreshLayout的子View不能接受到相应的事件。</p><p>在分Action处理事件之前有一段代码<br><pre><code>if (!isEnabled() || mReturningToStart || canChildScrollUp()                || mRefreshing || mNestedScrollInProgress) {            &#x2F;&#x2F; Fail fast if we&#39;re not in a state where a swipe is possible            return false;        }</code></pre></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
