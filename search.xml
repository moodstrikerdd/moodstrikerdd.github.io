<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ThreadPoolExecutor使用</title>
      <link href="/2019/03/07/threadPoolExecutor/"/>
      <url>/2019/03/07/threadPoolExecutor/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="ThreadPoolExecutor简介"><a href="#ThreadPoolExecutor简介" class="headerlink" title="ThreadPoolExecutor简介"></a>ThreadPoolExecutor简介</h3><p>线程池（ThreadPoolExecutor）是一种多线程处理形式，在线程池内有几个重要的元素，核心线程数，最大线程数，任务阻塞队列，拒绝策略。<br><img src="/2019/03/07/threadPoolExecutor/4.png" alt=""></p><h3 id="ThreadPoolExecutor构造函数"><a href="#ThreadPoolExecutor构造函数" class="headerlink" title="ThreadPoolExecutor构造函数"></a>ThreadPoolExecutor构造函数</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">///.....</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>ThreadFactory threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>RejectedExecutionHandler handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>TimeUnit unit<span class="token punctuation">,</span>        BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>ThreadFactory threadFactory<span class="token punctuation">,</span>RejectedExecutionHandler handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造函数中最终都是调用了最后一个参数最多的构造函数。<br>1.corePoolSize：核心线程数<br>2.maximumPoolSize：线程池最大线程数<br>3.keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；<br>4.unit：参数keepAliveTime的时间单位</p><pre><code>TimeUnit.DAYS;               //天TimeUnit.HOURS;             //小时TimeUnit.MINUTES;           //分钟TimeUnit.SECONDS;           //秒TimeUnit.MILLISECONDS;      //毫秒TimeUnit.MICROSECONDS;      //微妙TimeUnit.NANOSECONDS;       //纳秒</code></pre><p>5.workQueue:任务阻塞队列</p><pre><code>//常用阻塞队列ArrayBlockingQueue;//是一个用数组实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。LinkedBlockingQueue;//是一个链表实现的有界阻塞队列，此队列按照先进先出（FIFO）的原则对元素进行排序。SynchronousQueue;//一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。</code></pre><p>6.threadFactory：线程工厂，主要用来创建线程，可自定义。</p><pre><code>    new ThreadFactory() {        private AtomicInteger threadCount = new AtomicInteger(1);            @Override            public Thread newThread(@NonNull Runnable r) {                return new Thread(new ThreadGroup(&quot;abc&quot;),                                                       r,                                 &quot;DemoGo Thread &quot; + threadCount.getAndIncrement());            }    }</code></pre><p>7.handler：拒绝策略</p><pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 </code></pre><h3 id="ThreadPoolExecutor源码分析工作流程"><a href="#ThreadPoolExecutor源码分析工作流程" class="headerlink" title="ThreadPoolExecutor源码分析工作流程"></a>ThreadPoolExecutor源码分析工作流程</h3><h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><pre><code>public void execute(Runnable command) {        if (command == null)            throw new NullPointerException();        /*         * Proceed in 3 steps:         *         * 1. If fewer than corePoolSize threads are running, try to         * start a new thread with the given command as its first         * task.  The call to addWorker atomically checks runState and         * workerCount, and so prevents false alarms that would add         * threads when it shouldn&#39;t, by returning false.         * 2. If a task can be successfully queued, then we still need         * to double-check whether we should have added a thread         * (because existing ones died since last checking) or that         * the pool shut down since entry into this method. So we         * recheck state and if necessary roll back the enqueuing if         * stopped, or start a new thread if there are none.         * 3. If we cannot queue task, then we try to add a new         * thread.  If it fails, we know we are shut down or saturated         * and so reject the task.　　　　　　          */　　　　　　　　// 1.当前线程数量小于corePoolSize，则创建并启动线程。        int c = ctl.get();        if (workerCountOf(c) &lt; corePoolSize) {            if (addWorker(command, true))　　　　　　　　// 成功，则返回                return;            c = ctl.get();        }　　　　// 2.步骤1失败，则尝试进入阻塞队列，        if (isRunning(c) &amp;&amp; workQueue.offer(command)) {　　　　　　　// 入队列成功，检查线程池状态，如果状态部署RUNNING而且remove成功，则拒绝任务            int recheck = ctl.get();            if (! isRunning(recheck) &amp;&amp; remove(command))                reject(command);　　　　　　　// 如果当前worker数量为0，通过addWorker(null, false)创建一个线程，其任务为null            else if (workerCountOf(recheck) == 0)                addWorker(null, false);        }　　　　// 3. 步骤1和2失败，则尝试将线程池的数量有corePoolSize扩充至maxPoolSize，如果失败，则拒绝任务        else if (!addWorker(command, false))            reject(command);    }</code></pre><p>execute总结：<br>1.如果正在运行的线程数小于corePoolSize，那么将调用addWorker 方法来创建一个新的线程，并将该任务作为新线程的第一个任务来执行。当然，在创建线程之前会做原子性质的检查，如果条件不允许，则不创建线程来执行任务，并返回false.<br>2.如果一个任务成功进入阻塞队列，那么我们需要进行一个双重检查来确保是我们已经添加一个线程（因为存在着一些线程在上次检查后他已经死亡）或者当我们进入该方法时，该线程池已经关闭。所以，我们将重新检查状态，线程池关闭的情况下则回滚入队列，线程池没有线程的情况则创建一个新的线程。<br>3.如果任务无法入队列（队列满了），那么我们将尝试新开启一个线程（从corepoolsize到扩充到maximum），如果失败了，那么可以确定原因，要么是线程池关闭了或者饱和了（达到maximum），所以我们执行拒绝策略。</p><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><pre><code>private boolean addWorker(Runnable firstTask, boolean core) {        retry:　　　　 // 外层循环，用于判断线程池状态        for (;;) {            int c = ctl.get();            int rs = runStateOf(c);            // Check if queue empty only if necessary.            if (rs &gt;= SHUTDOWN &amp;&amp;                ! (rs == SHUTDOWN &amp;&amp;                   firstTask == null &amp;&amp;                   ! workQueue.isEmpty()))                return false;　　　　　　 // 内层的循环，任务是将worker数量加1            for (;;) {                int wc = workerCountOf(c);                if (wc &gt;= CAPACITY ||                    wc &gt;= (core ? corePoolSize : maximumPoolSize))                    return false;                if (compareAndIncrementWorkerCount(c))                    break retry;                c = ctl.get();  // Re-read ctl                if (runStateOf(c) != rs)                    continue retry;                // else CAS failed due to workerCount change; retry inner loop            }        }　　　　// worker加1后，接下来将woker添加到HashSet&lt;Worker&gt;中，并启动worker        boolean workerStarted = false;        boolean workerAdded = false;        Worker w = null;        try {            final ReentrantLock mainLock = this.mainLock;            w = new Worker(firstTask);            final Thread t = w.thread;            if (t != null) {                mainLock.lock();                try {                    // Recheck while holding lock.                    // Back out on ThreadFactory failure or if                    // shut down before lock acquired.                    int c = ctl.get();                    int rs = runStateOf(c);                    if (rs &lt; SHUTDOWN ||                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {                        if (t.isAlive()) // precheck that t is startable                            throw new IllegalThreadStateException();                        workers.add(w);                        int s = workers.size();                        if (s &gt; largestPoolSize)                            largestPoolSize = s;                        workerAdded = true;                    }                } finally {                    mainLock.unlock();                }　　　　　　　　　// 如果往HashSet&lt;Worker&gt;添加成功，则启动该线程                if (workerAdded) {                    t.start();                    workerStarted = true;                }            }        } finally {            if (! workerStarted)                addWorkerFailed(w);        }        return workerStarted;    }</code></pre><p>addWork总结：<br>1、判断线程池当前是否为可以添加worker线程的状态，可以则继续下一步，不可以return false：<br>    A、线程池状态&gt;shutdown，可能为stop、tidying、terminated，不能添加worker线程<br>    B、线程池状态==shutdown，firstTask不为空，不能添加worker线程，因为shutdown状态的线程池不接收新任务<br>    C、线程池状态==shutdown，firstTask==null，workQueue为空，不能添加worker线程，因为firstTask为空是为了添加一个没有任务的线程再从workQueue获取task，而workQueue为  　　　　空，说明添加无任务线程已经没有意义<br>2、线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），超过了return false，没超过则对workerCount+1，继续下一步<br>3、在线程池的ReentrantLock保证下，向Workers Set中添加新创建的worker实例，添加完成后解锁，并启动worker线程，如果这一切都成功了，return true，如果添加worker入Set失败或启动失败，调用addWorkerFailed()逻辑</p><h4 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h4><p>submit不是ThreadPoolExecutor的方法，而是父类AbstractExecutorService的方法。</p><pre><code>    public Future&lt;?&gt; submit(Runnable task) {        if (task == null) throw new NullPointerException();        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);        execute(ftask);        return ftask;    }    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {        if (task == null) throw new NullPointerException();        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);        execute(ftask);        return ftask;    }    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {        if (task == null) throw new NullPointerException();        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);        execute(ftask);        return ftask;    }</code></pre><p>可见submit方法实例化并返回的是一个RunnableFuture实例。</p><pre><code>    public FutureTask(Callable&lt;V&gt; callable) {        if (callable == null)            throw new NullPointerException();        this.callable = callable;        this.state = NEW;       // ensure visibility of callable    }    public FutureTask(Runnable runnable, V result) {        this.callable = Executors.callable(runnable, result); //将runnable对象转化成callable对象        this.state = NEW;       // ensure visibility of callable    }    public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {            if (task == null)                throw new NullPointerException();            return new RunnableAdapter&lt;T&gt;(task, result);    }    private static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; {            private final Runnable task;            private final T result;            RunnableAdapter(Runnable task, T result) {                this.task = task;                this.result = result;            }            public T call() {                task.run();                return result;            }        }</code></pre><p>在RunnableFuture中主要的属性为Callable<v> callable。</v></p><pre><code>public interface Callable&lt;V&gt; {    /**     * Computes a result, or throws an exception if unable to do so.     *     * @return computed result     * @throws Exception if unable to compute a result     */    V call() throws Exception;}</code></pre><p>通过RunnableFuture对象的get方法就可以获得返回结果。get方法是一个线程阻塞方法。</p><pre><code>    public V get() throws InterruptedException, ExecutionException {        int s = state;        if (s &lt;= COMPLETING)            s = awaitDone(false, 0L);//死循查询并等待rannable任务执行完成        return report(s);    }</code></pre><p>submit总结：<br>1.线程池submit一个callable或者runnable对象以及返回结果result（result默认为null）。<br>2.submit方法中实例化一个包装后的类型为Runnable的RunnableTask对象。<br>3.再调用execute方法将RunnableTask对象添加到任务中。RunnableTask对象的run方法中执行了被提交的任务，同时在任务执行结束之后将result设置成返回值。并且RunnableTask对象提供了get线程阻塞方法获取预先设置的返回值result。<br>4.将RunnableTask对象作为submit方法的返回值返回。</p><h3 id="常用的线程池"><a href="#常用的线程池" class="headerlink" title="常用的线程池"></a>常用的线程池</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><pre><code>    public static ExecutorService newFixedThreadPool(int var0) {        return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());    }    public static ExecutorService newFixedThreadPool(int var0, ThreadFactory var1) {        return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var1);    }</code></pre><p>固定大小的线程池，可以指定线程池的大小，该线程池corePoolSize和maximumPoolSize相等，阻塞队列使用的是LinkedBlockingQueue，大小为整数最大值。<br>该线程池中的线程数量始终不变，当有新任务提交时，线程池中有空闲线程则会立即执行，如果没有，则会暂存到阻塞队列。对于固定大小的线程池，不存在线程数量的变化。同时使用无界的LinkedBlockingQueue来存放执行的任务。当任务提交十分频繁的时候，LinkedBlockingQueue<br>迅速增大，存在着耗尽系统资源的问题。而且在线程池空闲时，即线程池中没有可运行任务时，它也不会释放工作线程，还会占用一定的系统资源，需要shutdown。</p><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><pre><code>    public static ExecutorService newSingleThreadExecutor() {        return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()));    }    public static ExecutorService newSingleThreadExecutor(ThreadFactory var0) {        return new Executors.FinalizableDelegatedExecutorService(new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), var0));    }</code></pre><p>单个线程线程池，只有一个线程的线程池，阻塞队列使用的是LinkedBlockingQueue,若有多余的任务提交到线程池中，则会被暂存到阻塞队列，待空闲时再去执行。按照先入先出的顺序执行任务。</p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><pre><code>    public static ExecutorService newCachedThreadPool() {        return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue());    }    public static ExecutorService newCachedThreadPool(ThreadFactory var0) {        return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue(), var0);    }</code></pre><p>缓存线程池，缓存的线程默认存活60秒。线程的核心池corePoolSize大小为0，核心池最大为Integer.MAX_VALUE,阻塞队列使用的是SynchronousQueue。是一个直接提交的阻塞队列，    他总会迫使线程池增加新的线程去执行新的任务。在没有任务执行时，当线程的空闲时间超过keepAliveTime（60秒），则工作线程将会终止被回收，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销。如果同时又大量任务被提交，而且任务执行的时间不是特别快，那么线程池便会新增出等量的线程池处理任务，这很可能会很快耗尽系统的资源。</p><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><pre><code>    public static ScheduledExecutorService newScheduledThreadPool(int var0) {        return new ScheduledThreadPoolExecutor(var0);    }    public static ScheduledExecutorService newScheduledThreadPool(int var0, ThreadFactory var1) {        return new ScheduledThreadPoolExecutor(var0, var1);    }</code></pre><p>定时线程池，该线程池可用于周期性地去执行任务，通常用于周期性的同步数据。<br>scheduleAtFixedRate:是以固定的频率去执行任务，周期是指每次执行任务成功执行之间的间隔。<br>schedultWithFixedDelay:是以固定的延时去执行任务，延时是指上一次执行成功之后和下一次开始执行的之前的时间。</p><h3 id="线程池规范"><a href="#线程池规范" class="headerlink" title="线程池规范"></a>线程池规范</h3><h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><p>实际使用线程池的过程中，如果安装了阿里巴巴开发手册插件，会出现以下几种警告。<br><img src="/2019/03/07/threadPoolExecutor/2.png" alt=""><br>在使用Executors工具类实例化线程的时候会出现以下隐患<br>1.newFixedThreadPool和newSingleThreadExecutor:主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。<br>2.newCachedThreadPool和newScheduledThreadPool:主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。<br><img src="/2019/03/07/threadPoolExecutor/3.png" alt=""><br>在使用ThreadPoolExecutor时自己实现ThreadFactory，从而方便设置所创建线程的ThreadGroup，name等参数。</p><h4 id="线程池大小选取"><a href="#线程池大小选取" class="headerlink" title="线程池大小选取"></a>线程池大小选取</h4><p>CPU数量NCPU获取方法</p><pre><code>Runtime.getRuntime().availableProcessors();</code></pre><p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1<br>如果是IO密集型任务，参考值可以设置为2*NCPU<br>当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android数据加密：MD5</title>
      <link href="/2019/01/29/md5/"/>
      <url>/2019/01/29/md5/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><p>Android数据加密相关博客：</p><p><a href="http://moodstrikerdd.github.io/2019/01/29/encryp">Android数据加密概述</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/base64">Android数据加密：Base64</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/aes">Android数据加密：AES</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/rsa">Android数据加密：RSA</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/md5">Android数据加密：MD5</a><br></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android数据加密：RSA</title>
      <link href="/2019/01/29/rsa/"/>
      <url>/2019/01/29/rsa/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><p>Android数据加密相关博客：</p><p><a href="http://moodstrikerdd.github.io/2019/01/29/encryp">Android数据加密概述</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/base64">Android数据加密：Base64</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/aes">Android数据加密：AES</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/rsa">Android数据加密：RSA</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/md5">Android数据加密：MD5</a><br></p><h3 id="RSA简介"><a href="#RSA简介" class="headerlink" title="RSA简介"></a>RSA简介</h3><p>RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用,既能用于数据加密也能用于数字签名的算法。RSA密钥长度随着保密级别提高，增加很快。</p><h3 id="RSA算法原理"><a href="#RSA算法原理" class="headerlink" title="RSA算法原理"></a>RSA算法原理</h3><h4 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h4><p>质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。</p><h4 id="互质关系"><a href="#互质关系" class="headerlink" title="互质关系"></a>互质关系</h4><p>如果两个<strong>正整数</strong>，除了 1 以外没有其他公因子，就称这两个数是互质关系。比如 3 和 5，13 和 31 等。</p><h4 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h4><p>求小于N的正整数中与N互质的数的数目。详细欧拉函数可参考<br><a href="https://blog.csdn.net/liuzibujian/article/details/81086324" target="_blank" rel="noopener">浅谈欧拉函数</a><br><br>RSA使用的是欧拉函数的一个特殊情况，对于质数p，φ(p)=p−1。如果N可以分解成两个互质的<strong>质数</strong>之积：N=pq φ(N)=φ(p)φ(q)=(p−1)(q−1)<br>例子：φ(21)=φ(3)φ(7) = (3 - 1)(7 - 1) = 12<br>对应21的互质数有：1,2,4,5,8,10,11,13,16,17,19,20 共12个。</p><h4 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h4><p>如果两个正整数 a 和 n 互质，那么一定可以找到整数 b，使得 ab−1 被 n 整除：<br>ab ≡ 1 (mod n)<br>这时，b 就叫做 a 的”模反元素”。模反元素不止一个。<br>例：3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。</p><h4 id="密钥生成步骤"><a href="#密钥生成步骤" class="headerlink" title="密钥生成步骤"></a>密钥生成步骤</h4><p>1.随机选择两个不相等的质数p和q。（实际应用中，这两个质数越大，就越难破解。）<br>2.计算得到N = pq。将N转换成2进制，N的长度就是密钥的长度。（实际应用中RSA密钥一般是1024位，更安全则为2048位）<br>3.计算N的欧拉函数φ(N) = (p-1)(q-1)。<br>4.选取一个整数e,要求E与φ(N)互质切1 &lt; e &lt; φ(N)<br>5.计算E对于φ(N)的模反元素D。ED ≡ 1(mod φ(N))课变换为 ED - 1 = kφ(N)<br>6.将N和E封装程公钥，N和D封装成私钥。</p><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>1.将明文变换成变换成1~N-1的一个整数M，若明文较长需要分组加密。<br>2.密文C ≡ M ^ E(mod N)。</p><h4 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h4><p>1.明文 M ≡ C ^ D(mod N)<br>2.将明文M转换成字符。</p><h3 id="Android中RSA使用"><a href="#Android中RSA使用" class="headerlink" title="Android中RSA使用"></a>Android中RSA使用</h3><h4 id="创建密钥（一般情况下非Android端操作）"><a href="#创建密钥（一般情况下非Android端操作）" class="headerlink" title="创建密钥（一般情况下非Android端操作）"></a>创建密钥（一般情况下非Android端操作）</h4><pre><code> /**     * 初始化密钥对，获得一对公钥和私钥     *     * @return Map     */    public static Map&lt;String, String&gt; initKey() throws Exception {        //实例化密钥生成器        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(RSA);        //初始化密钥生成器        keyPairGenerator.initialize(1024);        //生成密钥对        KeyPair keyPair = keyPairGenerator.generateKeyPair();        //甲方公钥        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();        //甲方私钥        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();        //将密钥存储在map中        Map&lt;String, String&gt; keyMap = new HashMap&lt;&gt;();        keyMap.put(PUBLIC_KEY, Base64.encodeToString(publicKey.getEncoded(),Base64.DEFAULT));        keyMap.put(PRIVATE_KEY, Base64.encodeToString(privateKey.getEncoded(),Base64.DEFAULT));        return keyMap;    }</code></pre><h4 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h4><pre><code>/**     * 公钥加密     *     * @param content   待加密数据     * @param publicKey 密钥     * @return string 加密后数据     */    public static String rsaEncryptByPublicKey(String content, String publicKey) throws Exception {        //初始化公钥        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(base64Decode(publicKey));        //产生公钥        PublicKey pubKey = keyFactory.generatePublic(x509KeySpec);        //数据加密        //PKCS1Padding        Cipher cipher = Cipher.getInstance(&quot;RSA/None/PKCS1Padding&quot;);        cipher.init(Cipher.ENCRYPT_MODE, pubKey);        return base64Encode(cipher.doFinal(content.trim().getBytes(DEFAULT_CHARSET)));    }</code></pre><h4 id="私钥解密"><a href="#私钥解密" class="headerlink" title="私钥解密"></a>私钥解密</h4><pre><code> /**     * 私钥解密     *     * @param encryptStr 待解密前数据     * @param privateKey 私钥     * @return string 解密后数据     */    public static String rsaDecryptByPrivateKey(String encryptStr, String privateKey) throws Exception {        //取得私钥        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(base64Decode(privateKey));        //生成私钥        PrivateKey priKey = keyFactory.generatePrivate(pkcs8KeySpec);        //数据解密        Cipher cipher = Cipher.getInstance(&quot;RSA/None/PKCS1Padding&quot;);        cipher.init(Cipher.DECRYPT_MODE, priKey);        return new String(cipher.doFinal(base64Decode(encryptStr)),&quot;utf-8&quot;);    }</code></pre><h3 id="Android端异常处理"><a href="#Android端异常处理" class="headerlink" title="Android端异常处理"></a>Android端异常处理</h3><p>1.异常描述：android客户端将要传送的信息，用私钥通过RSA非对称加密算法加密后，传到服务器端(PC端)。服务器端用对应(密钥)的公钥来解密时解密失败，抛出“javax.crypto.BadPaddingException: Blocktype”异常。<br>2.异常原因：Android系统使用的虚拟机（dalvik）跟SUN标准JDK是有所区别的，其中他们默认的RSA实现就不同。即Android端用Cipher.getInstance(“RSA”)方法进行加密时，使用的provider是Bouncycastle Security provider，Bouncycastle Security provider默认实现的是“RSA/None/NoPadding”算法，而服务器(PC)端用Cipher.getInstance(“RSA”)进行解密时，使用的是Sun的security provider，实现的是“RSA/None/PKCS1Padding”算法，所以，解密时会失败。<br>3.解决办法：<br>将Android端的Cipher.getInstance(“RSA”)方法改为Cipher.getInstance(“RSA/None/PKCS1Padding”)。</p><h3 id="RSA工具类"><a href="#RSA工具类" class="headerlink" title="RSA工具类"></a>RSA工具类</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RsaEncryptUtils</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PUBLIC_KEY <span class="token operator">=</span> <span class="token string">"PUBLIC_KEY"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PRIVATE_KEY <span class="token operator">=</span> <span class="token string">"PRIVATE_KEY"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> KeyFactory keyFactory<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String RSA <span class="token operator">=</span> <span class="token string">"RSA"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DEFAULT_CHARSET <span class="token operator">=</span> <span class="token string">"utf-8"</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//实例化密钥工厂</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            keyFactory <span class="token operator">=</span> KeyFactory<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>RSA<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchAlgorithmException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">base64Encode</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Base64<span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> Base64<span class="token punctuation">.</span>NO_WRAP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">base64Decode</span><span class="token punctuation">(</span>String base64Code<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">return</span> Base64<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>base64Code<span class="token punctuation">,</span> Base64<span class="token punctuation">.</span>NO_WRAP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 公钥加密     *     * @param content   待加密数据     * @param publicKey 密钥     * @return string 加密后数据     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">rsaEncryptByPublicKey</span><span class="token punctuation">(</span>String content<span class="token punctuation">,</span> String publicKey<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化公钥</span>        X509EncodedKeySpec x509KeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">X509EncodedKeySpec</span><span class="token punctuation">(</span><span class="token function">base64Decode</span><span class="token punctuation">(</span>publicKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//产生公钥</span>        PublicKey pubKey <span class="token operator">=</span> keyFactory<span class="token punctuation">.</span><span class="token function">generatePublic</span><span class="token punctuation">(</span>x509KeySpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//数据加密</span>        <span class="token comment" spellcheck="true">//PKCS1Padding</span>        Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"RSA/None/PKCS1Padding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>ENCRYPT_MODE<span class="token punctuation">,</span> pubKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">base64Encode</span><span class="token punctuation">(</span>cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>DEFAULT_CHARSET<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 私钥解密     *     * @param encryptStr 待解密前数据     * @param privateKey 私钥     * @return string 解密后数据     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">rsaDecryptByPrivateKey</span><span class="token punctuation">(</span>String encryptStr<span class="token punctuation">,</span> String privateKey<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//取得私钥</span>        PKCS8EncodedKeySpec pkcs8KeySpec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PKCS8EncodedKeySpec</span><span class="token punctuation">(</span><span class="token function">base64Decode</span><span class="token punctuation">(</span>privateKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//生成私钥</span>        PrivateKey priKey <span class="token operator">=</span> keyFactory<span class="token punctuation">.</span><span class="token function">generatePrivate</span><span class="token punctuation">(</span>pkcs8KeySpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//数据解密</span>        Cipher cipher <span class="token operator">=</span> Cipher<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">"RSA/None/PKCS1Padding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>Cipher<span class="token punctuation">.</span>DECRYPT_MODE<span class="token punctuation">,</span> priKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>cipher<span class="token punctuation">.</span><span class="token function">doFinal</span><span class="token punctuation">(</span><span class="token function">base64Decode</span><span class="token punctuation">(</span>encryptStr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 初始化密钥对，获得一对公钥和私钥     *     * @return Map     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> <span class="token function">initKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//实例化密钥生成器</span>        KeyPairGenerator keyPairGenerator <span class="token operator">=</span> KeyPairGenerator<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>RSA<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化密钥生成器</span>        keyPairGenerator<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//生成密钥对</span>        KeyPair keyPair <span class="token operator">=</span> keyPairGenerator<span class="token punctuation">.</span><span class="token function">generateKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//甲方公钥</span>        RSAPublicKey publicKey <span class="token operator">=</span> <span class="token punctuation">(</span>RSAPublicKey<span class="token punctuation">)</span> keyPair<span class="token punctuation">.</span><span class="token function">getPublic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//甲方私钥</span>        RSAPrivateKey privateKey <span class="token operator">=</span> <span class="token punctuation">(</span>RSAPrivateKey<span class="token punctuation">)</span> keyPair<span class="token punctuation">.</span><span class="token function">getPrivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//将密钥存储在map中</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> keyMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        keyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>PUBLIC_KEY<span class="token punctuation">,</span> Base64<span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>publicKey<span class="token punctuation">.</span><span class="token function">getEncoded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Base64<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        keyMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>PRIVATE_KEY<span class="token punctuation">,</span> Base64<span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>privateKey<span class="token punctuation">.</span><span class="token function">getEncoded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Base64<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> keyMap<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android数据加密：AES</title>
      <link href="/2019/01/29/aes/"/>
      <url>/2019/01/29/aes/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><p>Android数据加密相关博客：</p><p><a href="http://moodstrikerdd.github.io/2019/01/29/encryp">Android数据加密概述</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/base64">Android数据加密：Base64</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/aes">Android数据加密：AES</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/rsa">Android数据加密：RSA</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/md5">Android数据加密：MD5</a><br></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android数据加密：Base64</title>
      <link href="/2019/01/29/base64/"/>
      <url>/2019/01/29/base64/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><p>Android数据加密相关博客：</p><p><a href="http://moodstrikerdd.github.io/2019/01/29/encryp">Android数据加密概述</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/base64">Android数据加密：Base64</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/aes">Android数据加密：AES</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/rsa">Android数据加密：RSA</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/md5">Android数据加密：MD5</a><br></p><h3 id="Base64概述"><a href="#Base64概述" class="headerlink" title="Base64概述"></a>Base64概述</h3><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。<strong>Base64不是加密算法</strong>，一般配合数据加密算法实现数据加密传输。</p><p>对应表如下：</p><p><div align="center"><img src="/2019/01/29/base64/base64.png" alt=""></div></p><h3 id="Base64规则"><a href="#Base64规则" class="headerlink" title="Base64规则"></a>Base64规则</h3><p>1.标准Base64只有64个字符（英文大小写、数字和+、/）以及用作后缀等号”=”。<br>2.Base64是把3个字节变成4个可打印字符，所以Base64编码后的字符串一定能被4整除（不算用作后缀的等号）。<br>3.等号一定用作后缀，且数目一定是0个、1个或2个。这是因为如果原文字节长度不能被3(6和8的最小公倍数为24对应3个字节)整除，Base64要在后面添加0凑齐3n位。为了正确还原，添加了几个0就加上几个等号。显然添加等号的数目只能是0、1或2。<br>4.根据RFC822规定，BASE64Encoder编码每76个字符，还需要加上一个回车换行。</p><h3 id="Base64步骤及示例"><a href="#Base64步骤及示例" class="headerlink" title="Base64步骤及示例"></a>Base64步骤及示例</h3><p>1.将被编码数据转换成二进制。<br>2.二进制字节数不是24的倍数则末位补0（二进制为00000000）直到字节数是24的倍数。<br>3.将补全后的二进制数据6个字节一组分组。<br>4.每组数据高位补两个0形成新的二进制数据。<br>5.对照Base64编码表转义成可见字符，第二步添加了多少位二进制数据0，末位相应数量的0则转义成=，其余的0转义成A。</p><p>示例一：</p><p><div align="center"><img src="/2019/01/29/base64/base64_1.png" alt=""></div></p><p>示例二：</p><p><div align="center"><img src="/2019/01/29/base64/base64_2.png" alt=""></div></p><h3 id="Android中的Base64"><a href="#Android中的Base64" class="headerlink" title="Android中的Base64"></a>Android中的Base64</h3><pre><code>        val a = &quot;@&quot;        val b = &quot;Man&quot;        String(Base64.encode(a.toByteArray(), Base64.DEFAULT)) //QA==        val message = String(Base64.encode(b.toByteArray(), Base64.DEFAULT)) //TWFu        String(Base64.decode(message, Base64.DEFAULT))//Man</code></pre><h4 id="Base64参数说明"><a href="#Base64参数说明" class="headerlink" title="Base64参数说明"></a>Base64参数说明</h4><p>1.DEFAULT 这个参数是默认，使用默认的方法来加密</p><p>2.NO_PADDING 这个参数是略去加密字符串最后的”=”</p><p>3.NO_WRAP 这个参数意思是略去所有的换行符（设置后CRLF就没用了）</p><p>4.CRLF 这个参数看起来比较眼熟，它就是Win风格的换行符，意思就是使用CR LF这一对作为一行的结尾而不是Unix风格的LF</p><p>5.URL_SAFE 这个参数意思是加密时不使用对URL和文件名有特殊意义的字符来作为加密字符，具体就是以-和_取代+和/</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android数据加密概述</title>
      <link href="/2019/01/29/encryp/"/>
      <url>/2019/01/29/encryp/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><p>Android数据加密相关博客：</p><p><a href="http://moodstrikerdd.github.io/2019/01/29/encryp">Android数据加密概述</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/base64">Android数据加密：Base64</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/aes">Android数据加密：AES</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/rsa">Android数据加密：RSA</a><br><br><a href="http://moodstrikerdd.github.io/2019/01/29/md5">Android数据加密：MD5</a><br></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发中总会涉及到接口请求，而在一些对安全性要求比较高的接口请求中会对传输数据进行加密处理，所以准备系统的研究一下开发中所遇到的几种加密算法。</p><h3 id="加密算法简介"><a href="#加密算法简介" class="headerlink" title="加密算法简介"></a>加密算法简介</h3><p>加密算法的效能通常可以按照算法本身的复杂程度、密钥长度（密钥越长越安全）、加解密速度等来衡量。常见的加密算法可以分成三类，对称加密算法，非对称加密算法和Hash算法。</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>   指加密和解密使用相同密钥的加密算法。对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性。</p><p>   优点：加解密速度快，适合大量数据的加解密。</p><p>   缺点：加解密使用同一个密钥，不方便密钥的管理，密钥泄露后数据不安全。</p><p>   常见的对称加密算法：DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES</p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>   指加密和解密使用不同密钥的加密算法，也称为公私钥加密。假设两个用户要加密交换数据，双方交换公钥，使用时一方用对方的公钥加密，另一方即可用自己的私钥解密。</p><p>   优点：加解密密钥分开，便于密钥管理，安全性高。</p><p>   缺点：加解密速度低于对称加密。</p><p>   常见的非对称加密算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p><h4 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h4><p>   Hash算法特别的地方在于它是一种单向算法，用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。</p><p>   常见的Hash算法：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1</p><h3 id="加密算法应用"><a href="#加密算法应用" class="headerlink" title="加密算法应用"></a>加密算法应用</h3><p>非对称加密算法的运行速度比对称加密算法的速度慢很多，当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。对称加密算法不能实现签名，因此签名只能非对称算法。</p><p>对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。</p><p>在实际的操作过程中，我们通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</p><p>对用户密码一类不需要知道明文的数据传输时，采用hash算法加密，例如MD5，服务器只需要比对加密后的结果就可以了。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代理模式以及实现onClick事件预处理优化</title>
      <link href="/2019/01/08/proxy/"/>
      <url>/2019/01/08/proxy/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在之前的工作中封装过IOC实现的onClick事件注入及其网络和重复点击的判断（<a href="https://moodstrikerdd.github.io/2018/07/31/ioc-onclick/">IoC实现点击事件判断网络、防止连续点击</a>）。在后续的工作中发现对于onClick事件的相关判断可以通过代理的方式实现，因此对相关的封装代码做了相应的改动于封装。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。<br>以本次实现的onClick事件预处理为例。<br>1.具体需要实现的接口，OnClickListener。</p><pre><code> public interface OnClickListener {        void onClick(View v); }</code></pre><p> 2.判断网络状态的代理类，代理类实现了OnClickListener，同时代理类中持有一个OnClickListener的引用。在具体的onClick实现方法中，代理类先判断是否有网络，在有网络的情况下调用被代理OnClickListener的onClick方法，否则不触发点击事件。</p><pre><code> class OnClickListenerNetProxy(private val onClickListener: View.OnClickListener?) : View.OnClickListener {     override fun onClick(v: View) {         if (AppUtils.hasNet()) {             onClickListener?.onClick(v)         }     } }</code></pre><p>3.具体使用</p><pre><code> view.setOnClickListener(OnClickListenerNetProxy(View.OnClickListener {            toast(&quot;控件被点击了&quot;)        }))</code></pre><p>同样的，也可以定义防止重复点击的代理类嵌套使用。</p><pre><code>class OnClickListenerRepeatProxy(private val onClickListener: View.OnClickListener?,                                 private val second: Long = 1000) : View.OnClickListener {    private var lastClickTimeMills = 0L    override fun onClick(v: View) {        if (System.currentTimeMillis() - lastClickTimeMills &gt;= second) {            lastClickTimeMills = System.currentTimeMillis()            onClickListener?.onClick(v)        }    }}//嵌套调用，先防止重复点击，后判断有无网络，条件通过时处理点击事件。view.setOnClickListener(OnClickListenerRepeatProxy(OnClickListenerNetProxy(View.OnClickListener {            toast(&quot;控件被点击了&quot;)        })))</code></pre><p>联动<a href="https://moodstrikerdd.github.io/2018/07/31/ioc-onclick/">IoC实现点击事件判断网络、防止连续点击</a> 中的bind方法可以优化,从而不需要将所有的预处理都放到同一个地方执行。</p><pre><code>private fun injectOnClickAop(any: Any, contentView: View?) {        val javaClass = any.javaClass        val declaredMethods = javaClass.declaredMethods        if (declaredMethods != null &amp;&amp; declaredMethods.isNotEmpty()) {            declaredMethods.forEach { method -&gt;                val onClick = method.getAnnotation(OnClick::class.java)                val checkNet = method.getAnnotation(CheckNet::class.java)                val limitRepeatClick = method.getAnnotation(LimitRepeatClick::class.java)                if (onClick != null) {                    val values = onClick.value                    values.forEach { viewId -&gt;                        val view = (if (any is Activity) {                            any.findViewById(viewId)                        } else {                            contentView?.findViewById&lt;View&gt;(viewId)                        }) ?: throw RuntimeException(&quot;OnClick注解中存在无效id&quot;)                        var onClickListener = View.OnClickListener {                            method.isAccessible = true                            method.invoke(any, it)                        }                        if (checkNet != null &amp;&amp; (checkNet.value.isEmpty() || viewId in checkNet.value)) {                            onClickListener = OnClickListenerNetProxy(onClickListener)                        }                        if (limitRepeatClick != null) {                            onClickListener = OnClickListenerRepeatProxy(onClickListener, limitRepeatClick.value)                        }                        view.setOnClickListener(onClickListener)                    }                }            }        }    }</code></pre><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>代理类在程序运行时创建的代理方式被成为动态代理。动态代理代理类的Class文件有JDK在运行时创建。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。例如Retrofit框架中就是使用动态代理实现网络请求的统一处理。</p><pre><code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></pre><p>Proxy.newProxyInstance()方法有三个参数：</p><p>1.loader 类加载器(Class Loader)</p><p>2.interfaces 需要实现的接口数组</p><p>3.h InvocationHandler接口。所有动态代理类的方法调用，都会交由InvocationHandler接口实现类里的invoke()方法去处理。这是动态代理的关键所在。</p><pre><code>public interface InvocationHandler {    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable;}</code></pre><ol><li><p>动态代理类的引用，通常情况下不需要它。但可以使用getClass()方法，得到proxy的Class类从而取得实例的类信息，如方法列表，annotation等。</p></li><li><p>方法对象的引用，代表被动态代理类调用的方法。从中可得到方法名，参数类型，返回类型等等</p></li><li><p>args对象数组，代表被调用方法的参数。注意基本类型(int,long)会被装箱成对象类型(Interger, Long)</p></li></ol><p>例如定义一个请求数据的接口,以及实现。</p><pre><code>interface NetRequest {    fun getBean(): Person    fun getList(): List&lt;Person&gt;}class NetRequestImpl : NetRequest{    override fun getBean() = Person(&quot;张三&quot;, &quot;Moo&quot;)    override fun getList() = arrayListOf(            Person(&quot;张三&quot;, &quot;Moo&quot;),            Person(&quot;李四&quot;, &quot;Noo&quot;),            Person(&quot;王五&quot;, &quot;Ooo&quot;))}</code></pre><p>如果我们需要知道各个方法执行的时间，第一个想到的方法就是在调用方法的前后加上当前时间打印，但是这样有多少次调用就需要写多少次打印当前时间的代码。或者是使用静态代理的方式在具体实现方法前后加上时间打印，但是如果接口中的方法有很多的话，也会产生许多重复的工作。这里使用动态代理就十分的方便。</p><pre><code>//创建被代理接口的实现类val netRequestProxy = NetRequestImpl() //调用Api生成代理类val newProxyInstance = Proxy.newProxyInstance(NetRequest::class.java.classLoader,                arrayOf&lt;Class&lt;*&gt;&gt;(NetRequest::class.java)        ) { //此处为InvocationHandler接口的实现            _, p1, p -&gt;            if (p1.declaringClass == Any::class.java) {                //Object的方法一般不处理                p1.invoke(this, *p)            } else {                //接口中需要被代理的方法                loge(message = &quot;${p1.name} start:${System.currentTimeMillis()}&quot;)                //使用反射调用实现类的具体实现方法(kotlin中反射的入参为可变参数，而这里的P是Object[]类型，所以需要传入*p)                val invoke = p1.invoke(netRequestProxy, *p)                loge(message = &quot;${p1.name} end:${System.currentTimeMillis()}&quot;)                //返回对应代理方法的返回值                invoke            }        } as NetRequest        val bean = newProxyInstance.getBean()        val toString = newProxyInstance.getList()</code></pre><p>打印信息：<br>    getBean start:1546940670732<br>    getBean end:1546940670732<br>    getList start:1546940670734<br>    getList end:1546940670735</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射机制</title>
      <link href="/2018/08/06/java-reflection/"/>
      <url>/2018/08/06/java-reflection/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="Java反射机制简介"><a href="#Java反射机制简介" class="headerlink" title="Java反射机制简介"></a>Java反射机制简介</h3><p>JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><h3 id="Java反射的作用"><a href="#Java反射的作用" class="headerlink" title="Java反射的作用"></a>Java反射的作用</h3><p>在运行时判断任意一个对象所属的类。</p><p>在运行时构造任意一个类的对象。</p><p>在运行时判断任意一个类所具有的成员变量和方法。</p><p>在运行时调用任意一个对象的方法</p><h3 id="Java反射Api"><a href="#Java反射Api" class="headerlink" title="Java反射Api"></a>Java反射Api</h3><p>反射的常用类和函数:Java反射机制的实现要借助于4个类：Class，Constructor，Field，Method；其中class代表的是类对象，Constructor－类的构造器对象，Field－类的属性对象，Method－类的方法对象，通过这四个对象我们可以粗略的看到一个类的各个组成部分。</p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes.class字节码文件中。<strong> 在运行期间，一个类，只有一个Class对象产生 </strong></p><h5 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h5><p>1 Object ——&gt; getClass();</p><pre><code>A a = new A();Class aClass = a.getClass();</code></pre><p>2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</p><pre><code>Class aClass = A.class;</code></pre><p>3 通过Class类的静态方法：forName（String  className）(常用)</p><pre><code>try {        Class aClass = Class.forName(&quot;XXX.A&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名    } catch (ClassNotFoundException e) {        e.printStackTrace();    }</code></pre><h5 id="获得构造器的方法"><a href="#获得构造器的方法" class="headerlink" title="获得构造器的方法"></a>获得构造器的方法</h5><pre><code>Constructor getConstructor(Class[] params) -- 获得使用特殊的参数类型的公共构造函数， Constructor[] getConstructors() -- 获得类的所有公共构造函数 Constructor getDeclaredConstructor(Class[] params) -- 获得使用特定参数类型的构造函数Constructor[] getDeclaredConstructors() -- 获得类的所有构造函数</code></pre><h5 id="获得字段信息的方法"><a href="#获得字段信息的方法" class="headerlink" title="获得字段信息的方法"></a>获得字段信息的方法</h5><pre><code>Field getField(String name) -- 获得命名的公共字段 Field[] getFields() -- 获得类的所有公共字段 Field getDeclaredField(String name) -- 获得类声明的命名的字段 Field[] getDeclaredFields() -- 获得类声明的所有字段</code></pre><h5 id="获得方法信息的方法"><a href="#获得方法信息的方法" class="headerlink" title="获得方法信息的方法"></a>获得方法信息的方法</h5><pre><code>Method getMethod(String name, Class[] params) -- 使用特定的参数类型，获得命名的公共方法 Method[] getMethods() -- 获得类的所有公共方法 Method getDeclaredMethod(String name, Class[] params) -- 使用特写的参数类型，获得类声明的命名的方法 Method[] getDeclaredMethods() -- 获得类声明的所有方法</code></pre><h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><pre><code>Class&lt;T&gt; getDeclaringClass() -- 返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）Type[]    getGenericParameterTypes()    --按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。String    getName()    -- 以字符串形式返回此构造方法的名称。Class&lt;?&gt;[]    getParameterTypes()    -- 按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型T    newInstance(Object... initargs)    -- 使用此 Constructor对象表示的构造函数来创建新实例String    toGenericString()    -- 返回描述此 Constructor 的字符串，其中包括类型参数。</code></pre><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><pre><code>void    set(Object obj, Object value)    -- 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。Object    get(Object obj)    -- 返回指定对象上此 Field 表示的字段的值Class&lt;?&gt;    getType()    -- 返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。boolean    isEnumConstant()    -- 如果此字段表示枚举类型的元素则返回 true；否则返回 falseString    toGenericString()    -- 返回一个描述此 Field（包括其一般类型）的字符串String    getName()    -- 返回此 Field 对象表示的字段的名称Class&lt;?&gt;    getDeclaringClass()    -- 返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段void    setAccessible(boolean flag)    -- 将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</code></pre><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><pre><code>Object    invoke(Object obj, Object... args)    -- 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。Class&lt;?&gt;    getReturnType()    -- 返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型Type    getGenericReturnType()    -- 返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。Class&lt;?&gt;[]    getParameterTypes()    -- 按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组Type[]    getGenericParameterTypes()    -- 按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型String    getName()    -- 以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称boolean    isVarArgs()    -- 判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。String    toGenericString()    -- 返回描述此 Method 的字符串，包括类型参数。</code></pre>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Annotation</title>
      <link href="/2018/08/06/annotation/"/>
      <url>/2018/08/06/annotation/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="Annotation定义"><a href="#Annotation定义" class="headerlink" title="Annotation定义"></a>Annotation定义</h3><p>java.lang.annotation，接口 Annotation。对于Annotation，是Java5的新特性，JDK5引入了Metadata（元数据）很容易的就能够调用Annotations。Annotations提供一些本来不属于程序的数据，比如：一段代码的作者或者告诉编译器禁止一些特殊的错误。An annotation 对代码的执行没有什么影响。Annotations使用@annotation的形式应用于代码：类(class),属性(attribute),方法(method)等等。一个Annotation出现在上面提到的开始位置，而且一般只有一行，也可以包含有任意的参数。</p><h3 id="Annotation示例"><a href="#Annotation示例" class="headerlink" title="Annotation示例"></a>Annotation示例</h3><pre><code>//java中的Annotation@Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface MyAnnotation {}//kotlin中的Annotation@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.FUNCTION,AnnotationTarget.CLASS)annotation class OnClick(vararg val value: Int)</code></pre><h3 id="Annotation组成"><a href="#Annotation组成" class="headerlink" title="Annotation组成"></a>Annotation组成</h3><h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p>Target用来指定Annotation的类型，表明Annotation可以用在什么地方，一个Annotation可以有多个Target的值，表示可以用在不同的地方。java中的参数为ElementType，kotlin中的参数为AnnotationTarget。</p><pre><code>//java中的Targetpublic enum ElementType {    ANNOTATION_TYPE,    //注解    CONSTRUCTOR,        //构造函数    FIELD,              //字段（包括枚举常量）    LOCAL_VARIABLE,     //局部变量    METHOD,             //方法    PACKAGE,            //包    PARAMETER,          //参数    TYPE,               //类、接口（包括注解类型）或枚举    TYPE_PARAMETER,    TYPE_USE;    private ElementType() {    }}//kotlin中的targetpublic enum class AnnotationTarget {    /** Class, interface or object, annotation class is also included */    CLASS,    /** Annotation class only */    ANNOTATION_CLASS,    /** Generic type parameter (unsupported yet) */    TYPE_PARAMETER,    /** Property */    PROPERTY,    /** Field, including property&#39;s backing field */    FIELD,    /** Local variable */    LOCAL_VARIABLE,    /** Value parameter of a function or a constructor */    VALUE_PARAMETER,    /** Constructor only (primary or secondary) */    CONSTRUCTOR,    /** Function (constructors are not included) */    FUNCTION,    /** Property getter only */    PROPERTY_GETTER,    /** Property setter only */    PROPERTY_SETTER,    /** Type usage */    TYPE,    /** Any expression */    EXPRESSION,    /** File */    FILE,    /** Type alias */    @SinceKotlin(&quot;1.1&quot;)    TYPEALIAS}</code></pre><h4 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h4><p>Retention中的参数表示注解保留策略，一个Annotataion只能有一个Retention。此枚举类型的常量描述保留注解的不同策略，指定保留多长的注解。</p><pre><code>//java中的Retentionpublic enum RetentionPolicy {    CLASS,//编译器将注解存储于类对应的.class文件中，但是在运行时不能通过JVM读取（默认模式）    RUNTIME,//编译器将注解存储于.class文件中，并且可由反射获取    SOURCE;//编译器处理完之后就被抛弃    private RetentionPolicy() {    }}//kotlin中的Retentionpublic enum class AnnotationRetention {    /** Annotation isn&#39;t stored in binary output (同java中的SOURCE)*/    SOURCE,    /** Annotation is stored in binary output, but invisible for reflection(同java中的CLASS) */    BINARY,    /** Annotation is stored in binary output and visible for reflection (同java中的RUNTIME，默认模式) */    RUNTIME}</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p><pre><code>//java中注解的参数@Retention(RetentionPolicy.CLASS)@Target({ElementType.TYPE, ElementType.METHOD})public @interface JavaNetCheck {    int[] id();    String message();}//kotlin中注解的参数@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.FUNCTION)annotation class CheckNet(vararg val id: Int,val message:String)</code></pre><p>使用注解时，以key = value的形式传入相应的参数。</p><pre><code> @CheckNet(R.id.btnClick1,R.id.btnClick2, message = &quot;网络连接失败！&quot;) @JavaNetCheck(id = [R.id.btnClick1,R.id.btnClick2],message = &quot;网络连接失败！&quot;) private fun onClick(view: View) {    toast(&quot;${(view as Button).text}被点击了！&quot;) }</code></pre><p>java中如果参数名为value，则可以省略“value =”，直接赋值</p><pre><code>@Retention(RetentionPolicy.CLASS)@Target({ElementType.TYPE, ElementType.METHOD})public @interface JavaNetCheck {    int[] value();    String message();}@JavaNetCheck(R.id.btnClick1,R.id.btnClick2,message = &quot;网络连接失败！&quot;)private fun onClick(view: View) {    toast(&quot;${(view as Button).text}被点击了！&quot;)}</code></pre><p>同时，注解中的属性可以设置默认值，java使用default关键字，kotlin直接在参数列表中赋值默认值，在使用的时候该参数就为非必传参数，不传该参数的时候使用默认值。</p><pre><code>@Retention(RetentionPolicy.CLASS)@Target({ElementType.TYPE, ElementType.METHOD})public @interface JavaNetCheck {    int[] id();    String message() default &quot;网络连接失败！&quot;;}@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.FUNCTION)annotation class CheckNet(vararg val id: Int,val message :String = &quot;网络连接失败！&quot;)@CheckNet(R.id.btnClick1,R.id.btnClick2)@JavaNetCheck(id = [R.id.btnClick1,R.id.btnClick2])private fun onClick(view: View) {    toast(&quot;${(view as Button).text}被点击了！&quot;)}</code></pre><h3 id="Annotation与反射"><a href="#Annotation与反射" class="headerlink" title="Annotation与反射"></a>Annotation与反射</h3><p>了解了Annotation的基本内容，如果Annotation只是给编写代码的人注解标记，并不需要如此大费周章，注解的用途还是给java程序进行注解，标记。java提供了一个接口来获取注解的实例。</p><pre><code>public interface AnnotatedElement {    default boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; var1) {        return this.getAnnotation(var1) != null;    }    &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; var1);    Annotation[] getAnnotations();    default &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; var1) {        Annotation[] var2 = this.getDeclaredAnnotationsByType(var1);        if(var2.length == 0 &amp;&amp; this instanceof Class &amp;&amp; AnnotationType.getInstance(var1).isInherited()) {            Class var3 = ((Class)this).getSuperclass();            if(var3 != null) {                var2 = var3.getAnnotationsByType(var1);            }        }        return var2;    }    default &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass) {        Objects.requireNonNull(annotationClass);        // Loop over all directly-present annotations looking for a matching one           for (Annotation annotation : getDeclaredAnnotations()) {               if (annotationClass.equals(annotation.annotationType())) {                    // More robust to do a dynamic cast at runtime instead                    // of compile-time only.                    return annotationClass.cast(annotation);               }           }        return null;    }    default &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass) {        return AnnotatedElements.getDirectOrIndirectAnnotationsByType(this, annotationClass);    }    Annotation[] getDeclaredAnnotations();}</code></pre><p>AnnotatedElement常用的方法</p><p>1.isAnnotationPresent()方法可以判断该元素是否拥有指定注解类的注解，</p><p>2.getAnnotation(Class<t> var1) 则返回指定注解类的注解，</t></p><p>3.getAnnotations()则会返回所有的注解。</p><p>实现了这个接口的类有: Class,Constructor,Executable,Field,Method,Package,Parameter,AccessibleObject这些类都位于java.lang.reflect包，这意味着我们的程序需要通过反射来识别注解。</p><pre><code>val onClick = method.getAnnotation(OnClick::class.java)if (onClick != null) {     val values = onClick.value     ... ...    }</code></pre><h3 id="Kotlin-Annotation-扩展"><a href="#Kotlin-Annotation-扩展" class="headerlink" title="Kotlin Annotation 扩展"></a>Kotlin Annotation 扩展</h3><p>由于在Kotlin中的单个申明往往对应了多个Java声明，例如，一个Property对应了一个Field和Getter和Setter,为了使标注更为精确，Kotlin中还允许使用点目标。<br>点目标的语法为 @目标:注解名 例如:@get:MyAnnotation</p><pre><code>class Country{    /*对属性的getter使用注解*/    @get:MyAnnotation2(&quot;Editable&quot;)    var name : String = &quot;&quot;    /*对属性使用注解*/    @MyAnnotation2(&quot;Editable&quot;)    var pop : Int = 0    /*对属性的Setter使用注解*/    @MyAnnotation3(&quot;Editable&quot;,&quot;Can be below 0&quot;)    @set:MyAnnotation3    var coin : Int = 0    /*对生成的Field使用注解*/    /*具有setter的属性一般会自动生成backing field(后备字段)*/    @field:MyAnnotation2(&quot;&quot;)    var army : Int = 1000}</code></pre><p>在Kotlin中支持以下点目标:</p><p>property:代表kotlin中的属性，不能被Java的注解所应用</p><p>field:为属性生成的字段（包括后备字段）</p><p>get:属性的getter</p><p>set:属性的setter</p><p>receiver:扩展函数/属性的接收者</p><p>param:构造函数的参数</p><p>setparam:属性setter的参数</p><p>delegate:委托属性存储委托实例的字段</p><p>file:在文件中声明的顶层函数与类</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IoC实现点击事件判断网络、防止连续点击</title>
      <link href="/2018/07/31/ioc-onclick/"/>
      <url>/2018/07/31/ioc-onclick/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在使用Kotlin之前，在开发中为了提升效率，一直使用的ButterKnife，因为它通过注解的方式绑定控件，点击事件等等，不用每个控件去findViewById，功能非常便捷，而且可以通过安装ButterKnife插件一键生成代码。<br>但是在使用kotlin之后，ButterKnife的这一优势就不存在了，反而kotlin还不用为了给需要的控件创建对象而占用几十上百行代码。但是kotlin没有常用的onClick绑定，所以便自己用IoC封装了一个。虽然IoC使用反射是损耗性能的方法，但是个人认为就单单使用做onClick事件的绑定，并不会有很直观的影响，提高开发效率的意义更大。</p><h3 id="ioc简介"><a href="#ioc简介" class="headerlink" title="ioc简介"></a>ioc简介</h3><p>IoC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，IoC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI）。在java中使用发射+注解的方式即可实现。</p><h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><a href="http://moodstrikerdd.github.io/2018/08/06/annotation/">Annotation</a><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><a href="http://moodstrikerdd.github.io/2018/08/06/java-reflection//">反射</a><h3 id="封装使用"><a href="#封装使用" class="headerlink" title="封装使用"></a>封装使用</h3><pre><code>//Activity的onCreate方法中绑定AnnotationUtils().injectOnClick(this) @OnClick(R.id.btnClick1, R.id.btnClick2) @CheckNet(R.id.btnClick2) @LimitRepeatClick fun onClick(view: View) {    toast(&quot;${(view as Button).text}被点击了！&quot;) }</code></pre><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><pre><code> @Retention(AnnotationRetention.RUNTIME) @Target(AnnotationTarget.FUNCTION) annotation class OnClick(vararg val value: Int) @Retention(AnnotationRetention.RUNTIME) @Target(AnnotationTarget.FUNCTION) annotation class CheckNet(vararg val value: Int) @Retention(AnnotationRetention.RUNTIME) @Target(AnnotationTarget.FUNCTION) annotation class LimitRepeatClick(val value: Long = 1000) private fun injectOnClick(any: Any, contentView: View?) {        val javaClass = any.javaClass        val declaredMethods = javaClass.declaredMethods        if (declaredMethods != null &amp;&amp; declaredMethods.isNotEmpty()) {            declaredMethods.forEach { method -&gt;                val onClick = method.getAnnotation(OnClick::class.java)                val checkNet = method.getAnnotation(CheckNet::class.java)                val limitRepeatClick = method.getAnnotation(LimitRepeatClick::class.java)                if (onClick != null) {                    val values = onClick.value                    var offsetTime = 0L                    if (limitRepeatClick != null) {                        offsetTime = limitRepeatClick.value                    }                    values.forEach { viewId -&gt;                        val view = (if (any is Activity) {                            any.findViewById(viewId)                        } else {                            contentView?.findViewById&lt;View&gt;(viewId)                        }) ?: throw RuntimeException(&quot;OnClick注解中存在无效id&quot;)                        view.setOnClickListener {                            val lastTimeMillis = offsetTimes[viewId] ?: 0L                            val currentTimeMillis = System.currentTimeMillis()                            if (offsetTime == 0L || currentTimeMillis - lastTimeMillis &gt;= offsetTime) {                                offsetTimes[viewId] = currentTimeMillis                                if (checkNet == null || checkNet.value.isEmpty() || !checkNet.value.contains(viewId) || AppUtils.hasNet()) {                                    method.isAccessible = true                                    method.invoke(any, view)                                }                            }                        }                    }                }            }        }    }</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> kotlin </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>WebView POST封装</title>
      <link href="/2018/07/20/WebView/"/>
      <url>/2018/07/20/WebView/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在最近的开发中碰到了一下运用场景，当调用第三方的银行合作接口之后，app需要跳转到第三方银行的H5页面进行操作，本以为银行的接口会返回一个url然后通过get方式将app中的参数传给第三方H5。但是接口返回的是一个url和一个密文参数，由于安全性，银行的H5需要通过用POST请求将参数带入从而展示页面，碍于以前没有接触，下意识的以为Android的WebView不能实现，查阅过一些资料之后发现Android的WebView是可以通过POST请求的方式打开相应的网页。</p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><pre><code> //GET方式请求网页 public void loadUrl(String url) //POST方式请求网页（若url不是http或者https链接，还是会调用GET请求方式） public void postUrl(String url, byte[] postData) //调用方法  val url = &quot;https://aaa...&quot;;  val param = &quot;abcd&quot;;  //根据需求是否需要将参数加密，如Base64加密  param = Base64.encode(param.toByteArray(), Base64.DEFAULT).toString(Charsets.UTF_8)  //因为在网络传输过程中有特殊符号会自动被转义，例如‘+’等需要将参数编码后传输  val paramString = &quot;key=&quot;+URLEncoder.encode(param, &quot;UTF-8&quot;)  //url 和 params都准备好之后，就可以处理请求  webView.poutUrl(url,paramString.toByteArray())</code></pre><h3 id="请求封装"><a href="#请求封装" class="headerlink" title="请求封装"></a>请求封装</h3><p>通用WebView中需要满足GET和POST两种请求方式，所以在转到WebView的activity中时需要传POST和GET的标记量，参数由于可能有多个的情况，所以WebView中需要用Map&lt;String,String&gt;接收。<br>核心代码：</p><pre><code>companion object {    fun intentStart(context: Context, url: String, title: String?) {        val intent = Intent(context, WebViewActivity::class.java)        intent.putExtra(DefineKey.URL, url)        intent.putExtra(DefineKey.TITLE, title ?: &quot;网页&quot;)        context.startActivity(intent)    }    fun intentStart(context: Context, url: String, title: String?, params: HashMap&lt;String, String&gt;) {        val intent = Intent(context, WebViewActivity::class.java)        intent.putExtra(DefineKey.USE_POST, true)        intent.putExtra(DefineKey.URL, url)        intent.putExtra(DefineKey.TITLE, title ?: &quot;网页&quot;)        intent.putExtra(DefineKey.PARAMS_MAP, params)        context.startActivity(intent)    }}if (usePost) {    val sb = StringBuilder()    params.forEach { key, value -&gt;        sb.append(&quot;$key=${URLEncoder.encode(value, &quot;UTF-8&quot;)}&quot;)    }    webView.postUrl(url, sb.toString().toByteArray())} else {    webView.loadUrl(url)}</code></pre><h3 id="使用POST的问题"><a href="#使用POST的问题" class="headerlink" title="使用POST的问题"></a>使用POST的问题</h3><p>在成功使用POST去请求加载出页面只有，发现的新的问题：在第一个页面中输入相关信息，点击跳转到了下一个网页，再点返回键的时候第一个界面会加载失败，原因肯定是返回时第一个界面重新加载了，给WebView加上缓存，会发现缓存在POST请求的时候并不会生效。解决方式：</p><p>在一开始加载的时候我们定义了一个布尔值 userPost表示当前界面是不是使用POST请求，那么在shouldOverrideUrlLoading中就可以根据这个变量使后面的url跳转到一个新的Activity去处理</p><pre><code>  if (usePost) {    WebViewActivity.intentStart(this, url, null)    return true  }  return false</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>6.0和8.0运行时权限处理</title>
      <link href="/2018/06/05/runtime-permission/"/>
      <url>/2018/06/05/runtime-permission/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Android 6.0 SDK 23的时候，google为了安全推出了运行时权限，控制app对用户手机权限的获取。在Android 8.0 SDK 26的时候，google进一步的优化了运行时权限。</p><h3 id="6-0运行时权限"><a href="#6-0运行时权限" class="headerlink" title="6.0运行时权限"></a>6.0运行时权限</h3><h4 id="运行时权限简介"><a href="#运行时权限简介" class="headerlink" title="运行时权限简介"></a>运行时权限简介</h4><p>在6.0以前，即targetSdkVersion &lt; 23时，app获取用户手机权限，只需要在AndroidManifest.xml文件中声明相应权限即可，如：</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</code></pre><p>而在6.0以后，想要获取某些敏感权限不仅仅需要在AndroidManifest.xml文件中声明，还要通过运行时权限Api去动态获取，用户可以根据具体使用情况授权相应权限或者拒绝相应授权。</p><h4 id="敏感权限"><a href="#敏感权限" class="headerlink" title="敏感权限"></a>敏感权限</h4><p>google官方文档上有相应表格显示哪些是敏感权限，即需要兼容运行时权限的权限和权限组。</p><p><div align="center"><img src="/2018/06/05/runtime-permission/permissions.png" alt=""></div></p><h4 id="运行时权限Api"><a href="#运行时权限Api" class="headerlink" title="运行时权限Api"></a>运行时权限Api</h4><p>关于运行时权限，在support包中的ActivityCompat中提供了相应的Api</p><pre><code>public static int checkSelfPermission(@NonNull Context context, @NonNull String permission)public static void requestPermissions(final @NonNull Activity activity,            final @NonNull String[] permissions, final @IntRange(from = 0) int requestCode)public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,            @NonNull int[] grantResults)public static boolean shouldShowRequestPermissionRationale(@NonNull Activity activity,            @NonNull String permission)</code></pre><p><strong>checkSelfPermission</strong>：检查app是否已经被授权了某个权限，一般在请求权限之前调用。</p><p>   android.content.pm.PackageManager#PERMISSION_GRANTED 已经授权 </p><p>   android.content.pm.PackageManager#PERMISSION_DENIED 没有授权<br><strong>requestPermission</strong>：请求权限，可同时请求多个。当用户已经拒绝过该权限切选择了不再提醒 requestPermission将不会获取权限<br><strong>onRequestPermissionsResult</strong>：Activity中请求权限的结果回调<br><strong>shouldShowRequestPermissionRationale</strong>字面意思是是否应该显示请求权限的根据，在使用中有以下情况</p><p>   1.没有请求该权限之前，返回false</p><p>   2.请求拒绝该权限，但是没有选择不再提醒，返回true</p><p>   3.请求拒绝该权限，选择不再提醒，返回false（不再提醒选项一般第二次请求的时候出现）</p><h4 id="运行时权限封装"><a href="#运行时权限封装" class="headerlink" title="运行时权限封装"></a>运行时权限封装</h4><pre><code>/** * @author moodstrikerdd * @date 2018/5/31 * @label 运行时权限帮助类 */object RuntimePermissionHelper {    val permissions = arrayListOf&lt;String&gt;()    private val permissionNotAllowed = arrayListOf&lt;String&gt;()    private const val REQUEST_CODE_PERMISSION = 1001    private var requestCode = 0    /**     * 检查相应权限是否已经获取，没获取的权限放入permissionNotAllowed List中     */    fun checkPermissions(activity: Activity): Boolean {        if (Build.VERSION.SDK_INT &lt; 23) {            return true        }        permissionNotAllowed.clear()        permissions.forEach {            if (ActivityCompat.checkSelfPermission(activity, it) != PackageManager.PERMISSION_GRANTED) {                permissionNotAllowed.add(it)            }        }        return permissionNotAllowed.isEmpty()    }    /**     * 方式一 请求权限     * 先判断shouldShowRequestPermissionRationale，根据返回值决定是跳转设置界面还是请求权限     */    fun requestPermissions(activity: Activity, requestCode: Int = REQUEST_CODE_PERMISSION) {        if (Build.VERSION.SDK_INT &lt; 23) {            return        }        for (i in 0 until permissionNotAllowed.size) {            val shouldShow = ActivityCompat.shouldShowRequestPermissionRationale(activity, permissionNotAllowed[i])            val requested = SPUtils.get(permissionNotAllowed[i], false) as Boolean            if (requested &amp;&amp; !shouldShow) {                AlertDialog.Builder(activity)                        .setTitle(&quot;提示&quot;)                        .setMessage(&quot;当前应用缺少权限:${Permission.getPermissionName(permissionNotAllowed.toTypedArray())}。请点击\&quot;设置\&quot;,\&quot;权限\&quot;打开相应权限&quot;)                        .setPositiveButton(&quot;设置&quot;) { _, _ -&gt; AppUtils.getAppDetailSettingIntent(activity) }                        .setNegativeButton(&quot;取消&quot;) { dialog, _ -&gt; dialog.dismiss() }                        .create()                        .show()                return            }        }        RuntimePermissionHelper.requestCode = requestCode        permissionNotAllowed.forEach { SPUtils.put(it, true) }        ActivityCompat.requestPermissions(activity, permissionNotAllowed.toTypedArray(), requestCode)    }    /**     * 方式二 请求权限     * 直接请求未授权的权限     */    fun requestPermissions2(activity: Activity, requestCode: Int = REQUEST_CODE_PERMISSION) {        if (Build.VERSION.SDK_INT &lt; 23) {            return        }        RuntimePermissionHelper.requestCode = requestCode        permissionNotAllowed.forEach { SPUtils.put(it, true) }        ActivityCompat.requestPermissions(activity, permissionNotAllowed.toTypedArray(), requestCode)    }    /**     * 方式二 直接请求所有权限     */    fun requestPermissionsWithoutCheck(activity: Activity, requestCode: Int = REQUEST_CODE_PERMISSION) {        if (Build.VERSION.SDK_INT &lt; 23) {            return        }        RuntimePermissionHelper.requestCode = requestCode        ActivityCompat.requestPermissions(activity, permissions.toTypedArray(), requestCode)    }    /**     * 方式一 结果回调 只存在 获取权限失败和成功     */    fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray, success: (requestCode: Int) -&gt; Unit) {        if (requestCode == RuntimePermissionHelper.requestCode) {            for (i in 0 until permissions.size) {                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {                    toast(message = &quot;必须同意所有该类权限才能使用本程序&quot;)                    return                }            }            success(requestCode)        }    }    /**     * 方式二 结果回调     * 在回调结果中判断 shouldShowRequestPermissionRationale     * 三种结果     * 1.提示获取权限失败     * 2.跳转设置界面     * 3.获取权限成功     */    fun onRequestPermissionsResult2(activity: Activity, requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray, success: (requestCode: Int) -&gt; Unit) {        if (requestCode == RuntimePermissionHelper.requestCode) {            val permissionsNotAllowed = permissions.filterIndexed { index, _ -&gt;                grantResults[index] != PackageManager.PERMISSION_GRANTED            }            for (i in 0 until permissions.size) {                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {                    if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permissions[i])) {                        toast(message = &quot;必须同意${Permission.getPermissionName(permissionsNotAllowed.toTypedArray())}权限才能使                    } else {                        AlertDialog.Builder(activity)                                .setTitle(&quot;提示&quot;)                                .setMessage(&quot;当前应用缺少权限:${Permission.getPermissionName(permissionsNotAllowed.toTypedArray())}。请点击\&quot;设置\&quot;,\&quot;权限\&quot;打开相应权限&quot;)                                .setPositiveButton(&quot;设置&quot;) { _, _ -&gt; AppUtils.getAppDetailSettingIntent(activity) }                                .setNegativeButton(&quot;取消&quot;) { dialog, _ -&gt; dialog.dismiss() }                                .create()                                .show()                    }                    return                }            }            success(requestCode)        }    }}</code></pre><p>区别在于shouldShowRequestPermissionRationale的调用位置<br>1.在请求权限之前调用，当shouldShowRequestPermissionRationale返回false的时候跳转设置界面，返回true的时候调用requestPermissions请求权限<br>shouldShowRequestPermissionRationale返回false跳转设置界面是因为此时requestPermission已经不能获取权限，但是返回false的时候会有一个特殊情况就是当还未请求权限时，<br>因此需要通过SharedPreferences记录是否已经请求过该权限。在还未请求过时，请求权限，已经请求过的同时shouldShowRequestPermissionRationale发挥false的时候跳转到设置界面</p><pre><code>for (i in 0 until permissionNotAllowed.size) {            val shouldShow = ActivityCompat.shouldShowRequestPermissionRationale(activity, permissionNotAllowed[i])            val requested = SPUtils.get(permissionNotAllowed[i], false) as Boolean            if (requested &amp;&amp; !shouldShow) {                //TODO 跳转设置界面                return            }        }        RuntimePermissionHelper.requestCode = requestCode        //可请求权限，并让请求的权限标记为已请求        permissionNotAllowed.forEach { SPUtils.put(it, true) }        ActivityCompat.requestPermissions(activity, permissionNotAllowed.toTypedArray(), requestCode)</code></pre><p>2.在返回结果中调用，这种方式是为了避免还未请求时shouldShowRequestPermissionRationale返回false的特殊情况。<br>在请求权限失败的时候判断shouldShowRequestPermissionRationale的返回值，返回true的时候提示获取权限失败，false的时候跳转到设置界面。</p><pre><code>fun onRequestPermissionsResult2(activity: Activity, requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray, success: (requestCode: Int) -&gt; Unit) {        if (requestCode == RuntimePermissionHelper.requestCode) {            val permissionsNotAllowed = permissions.filterIndexed { index, _ -&gt;                grantResults[index] != PackageManager.PERMISSION_GRANTED            }            for (i in 0 until permissions.size) {                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {                    if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permissions[i])) {                        toast(message = &quot;必须同意${Permission.getPermissionName(permissionsNotAllowed.toTypedArray())}权限才能使                    } else {                       //TODO 跳转设置界面                    }                    return                }            }            success(requestCode)        }    }</code></pre><h3 id="8-0运行时权限"><a href="#8-0运行时权限" class="headerlink" title="8.0运行时权限"></a>8.0运行时权限</h3><p>在6.0到8.0之间的版本中，在运行时权限申请时，授权了组中的一个权限，会同时授权权限组中其他所有权限。而在8.0及以上版本中授权组中的一个权限，并不同时授权组中其他的权限，但是当你再次请求组中其他权限的时候，会直接授权，不需要用户选择。<br>例如 Manifest.permission.READ_EXTERNAL_STORAGE和Manifest.permission.WRITE_EXTERNAL_STORAGE，在6.0~8.0之间只需请求其中一个，另一个就会同时授权，而在8.0以上，授权了其中一个，当需要另一个权限的时候需要再次手动调用requestPermission，否则不会获的授权。<br>适配方式：<br>        1.请求权限时，将同组的权限全部请求授权。<br>        2.在每个需要权限的地方，都去申请相关权限。</p><pre><code>/** * @author moodstrikerdd * @date 2018/5/31 * @label 6.0运行时权限 */object Permission {    /**     *读写日历。     */    val CALENDAR: Array&lt;String&gt;    /**     * 相机。     */    val CAMERA: Array&lt;String&gt;    /**     * 读写联系人。     */    val CONTACTS: Array&lt;String&gt;    /**     * 读位置信息。     */    val LOCATION: Array&lt;String&gt;    /**     * 使用麦克风。     */    val MICROPHONE: Array&lt;String&gt;    /**     * 读电话状态、打电话、读写电话记录。     */    val PHONE: Array&lt;String&gt;    /**     * 传感器。     */    val SENSORS: Array&lt;String&gt;    /**     * 读写短信、收发短信。     */    val SMS: Array&lt;String&gt;    /**     * 读写存储卡。     */    val STORAGE: Array&lt;String&gt;    init {        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) {            CALENDAR = arrayOf()            CAMERA = arrayOf()            CONTACTS = arrayOf()            LOCATION = arrayOf()            MICROPHONE = arrayOf()            PHONE = arrayOf()            SENSORS = arrayOf()            SMS = arrayOf()            STORAGE = arrayOf()        } else {            CALENDAR = arrayOf(                    Manifest.permission.READ_CALENDAR,                    Manifest.permission.WRITE_CALENDAR)            CAMERA = arrayOf(                    Manifest.permission.CAMERA)            CONTACTS = arrayOf(                    Manifest.permission.READ_CONTACTS,                    Manifest.permission.WRITE_CONTACTS,                    Manifest.permission.GET_ACCOUNTS)            LOCATION = arrayOf(                    Manifest.permission.ACCESS_FINE_LOCATION,                    Manifest.permission.ACCESS_COARSE_LOCATION)            MICROPHONE = arrayOf(                    Manifest.permission.RECORD_AUDIO)            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {                PHONE = arrayOf(                        Manifest.permission.READ_PHONE_STATE,                        Manifest.permission.READ_PHONE_NUMBERS,                        Manifest.permission.ANSWER_PHONE_CALLS,                        Manifest.permission.ADD_VOICEMAIL,                        Manifest.permission.CALL_PHONE,                        Manifest.permission.READ_CALL_LOG,                        Manifest.permission.WRITE_CALL_LOG,                        Manifest.permission.USE_SIP,                        Manifest.permission.PROCESS_OUTGOING_CALLS)            } else {                PHONE = arrayOf(                        Manifest.permission.READ_PHONE_STATE,                        Manifest.permission.ADD_VOICEMAIL,                        Manifest.permission.CALL_PHONE,                        Manifest.permission.READ_CALL_LOG,                        Manifest.permission.WRITE_CALL_LOG,                        Manifest.permission.USE_SIP,                        Manifest.permission.PROCESS_OUTGOING_CALLS)            }            SENSORS = arrayOf(                    Manifest.permission.BODY_SENSORS)            SMS = arrayOf(                    Manifest.permission.SEND_SMS,                    Manifest.permission.RECEIVE_SMS,                    Manifest.permission.READ_SMS,                    Manifest.permission.RECEIVE_WAP_PUSH,                    Manifest.permission.RECEIVE_MMS)            STORAGE = arrayOf(                    Manifest.permission.READ_EXTERNAL_STORAGE,                    Manifest.permission.WRITE_EXTERNAL_STORAGE)        }    }    /**     * 获取单个权限的名称     */    fun getPermissionName(permission: String): String {        var permissionName = &quot;&quot;        when {            CALENDAR.contains(permission) -&gt; permissionName = &quot;日历&quot;            CAMERA.contains(permission) -&gt; permissionName = &quot;相机&quot;            CONTACTS.contains(permission) -&gt; permissionName = &quot;联系人&quot;            LOCATION.contains(permission) -&gt; permissionName = &quot;定位&quot;            MICROPHONE.contains(permission) -&gt; permissionName = &quot;麦克风&quot;            PHONE.contains(permission) -&gt; permissionName = &quot;电话&quot;            SENSORS.contains(permission) -&gt; permissionName = &quot;传感器&quot;            SMS.contains(permission) -&gt; permissionName = &quot;短信&quot;            STORAGE.contains(permission) -&gt; permissionName = &quot;读写存储&quot;        }        return permissionName    }    /**     * 获取权限的拼接名称     */    fun getPermissionName(permission: Array&lt;String&gt;): String {        val sb = StringBuilder()        permission.forEach {            val permissionName = getPermissionName(it)            if (!TextUtils.isEmpty(permissionName) &amp;&amp; !sb.contains(permissionName)) {                sb.append(&quot;$permissionName、&quot;)            }        }        sb.deleteCharAt(sb.length - 1)        return sb.toString()    }}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>width-length-ems</title>
      <link href="/2018/05/02/width-length-ems/"/>
      <url>/2018/05/02/width-length-ems/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在DemoGo中自定义公共页面头部CommTopBar时，最开始没有限制title的长度、行数,导致在title过长时，会占满整个CommTopBar。而在TextView的文本限制中官方有3种方式，maxWidth、maxEms、maxLength。</p><h3 id="maxWidth"><a href="#maxWidth" class="headerlink" title="maxWidth"></a>maxWidth</h3><p>maxWidth，传入值为dimens，TextView layout_width必须为”wrap_content”,否则该属性失效。当TextView设置maxWidth属性之后，TextView的最大宽度固定，当TextView中文字长度大于TextView的宽度时，会换行。当打到maxLines之后,ellipsize会生效。</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxLines=&quot;2&quot;        android:maxWidth=&quot;100dp&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text1.png" alt=""></p><h3 id="maxLength"><a href="#maxLength" class="headerlink" title="maxLength"></a>maxLength</h3><p>maxLength,传入值为整形，TextView layout_width可以随意赋值。设置该属性之后TextView只会展示限制长度之内的text。</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxLines=&quot;1&quot;        android:maxLength=&quot;10&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text3.png" alt=""></p><h3 id="maxEms"><a href="#maxEms" class="headerlink" title="maxEms"></a>maxEms</h3><p>maxEms,传入值为整形，TextView layout_width必须为wrap_content。例如设置maxEms=”10”,相当于规定TextView最大宽度为10em的长度。em为一个是长度单位，是根据文字的size来决定。（详情可以参考<a href="https://en.wikipedia.org/wiki/Em_%28typography%29" target="_blank" rel="noopener">Em (typography)</a>）</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxEms=&quot;10&quot;        android:maxLines=&quot;2&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text2.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="限制TextView宽度方法"><a href="#限制TextView宽度方法" class="headerlink" title="限制TextView宽度方法"></a>限制TextView宽度方法</h4><p>1.直接限制TextView的layout_width,缺点：当文本未超出TextView的宽度时，TextView还是会占用相应大小。<br>2.maxWidth，maxWidth结合wrap_content使用，给TextView规定了最大宽度，未超过时TextView根据文本计算长度，超过时TextView宽度固定为最大宽度。<br>3.maxEms，maxEms和maxWidth相同，也是给TextView规定了最大宽度，和maxWidth的区别在于最大宽度的单位是em，而em的长度取决于字体大小。<br>4.maxLength，maxLength并不是处理TextView，而是处理设置的text，设置该属性，TextView只会展示限定范围内的text。</p><h4 id="ellipsize是否生效"><a href="#ellipsize是否生效" class="headerlink" title="ellipsize是否生效"></a>ellipsize是否生效</h4><p>1.TextView layout_width设置为固定宽度，无论是否设置maxWidth、maxEms或者maxLength，只要text文本超过了TextView的宽度和最大行数，ellipsize就会生效。<br>2.TextView layout_width设置为wrap_content，maxWidth、maxEms会使ellipsize生效，maxLength会使ellipsize失效。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit+Kotlin协程封装</title>
      <link href="/2018/04/26/retrofit-coroutines/"/>
      <url>/2018/04/26/retrofit-coroutines/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇博客<a href="http://moodstrikerdd.com/2018/04/26/kotlin-coroutines/" target="_blank" rel="noopener">Kotlin协程Api用例详解</a>中了解了Kotlin协程Api的使用。目前火热的Retrofit网络请求框架也支持了Kotlin协程，本篇博客中就</p><pre><code>//集成准备    //Kotlin协程    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:0.22.5&quot;    //okhttp log拦截器    implementation &#39;com.squareup.okhttp3:logging-interceptor:3.10.0&#39;    //Retrofit2    implementation &#39;com.squareup.retrofit2:retrofit:2.4.0&#39;    //Retrofit2 gson转换器    implementation &#39;com.squareup.retrofit2:converter-gson:2.4.0&#39;    //Retrofit2 协程适配器    implementation &#39;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-experimental-adapter:1.0.0&#39;</code></pre><h3 id="Retrofit2单例"><a href="#Retrofit2单例" class="headerlink" title="Retrofit2单例"></a>Retrofit2单例</h3><p>在Retrofit是用中，推荐使用单例封装，Kotlin中使用单例也非常方便，object为单例class，参数单例可用委托by lazy</p><pre><code>/** * @author moodstrikerdd * @date 2018/4/19 * @label 单例Retrofit Retrofit帮助类 */object RetrofitHelper {    private const val BASE_URL = &quot;http://www.wanandroid.com&quot;    private const val CONNECT_TIMEOUT = 30L    private const val READ_TIMEOUT = 10L    private const val TAG = &quot;Retrofit:&quot;    private const val DATA_FRONT = &quot;Data:&quot;    //实例化api    val api: ApiService by lazy {        getService(ApiService::class.java)    }    //实例化Gson，用于控制台格式化输出json    private val gson: Gson by lazy {        GsonBuilder().setPrettyPrinting().create()    }    //实例化Retrofit    private val mRetrofit: Retrofit by lazy {        Retrofit.Builder().apply {            baseUrl(BASE_URL)            client(OkHttpClient().newBuilder().apply {                connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS)                readTimeout(READ_TIMEOUT, TimeUnit.SECONDS)                addInterceptor {                    val request = it.request()                    val newBuilder = request.newBuilder()                    //请求预处理，此处没做处理                    it.proceed(newBuilder.build())                }                //log拦截器一定要最后添加，否则后面添加的拦截器修改的内容不会打印                addInterceptor(HttpLoggingInterceptor(HttpLoggingInterceptor.Logger {                    loge(TAG, if (it.startsWith(&quot;{&quot;)) {                        //控制台格式化输出json                        val fromJson = gson.fromJson(it, Any::class.java)                        DATA_FRONT + gson.toJson(fromJson)                    } else {                        DATA_FRONT + it                    })                }))            }.build())                    //添加gson转换器                    .addConverterFactory(GsonConverterFactory.create())                    //添加Kotlin 协程适配器                    .addCallAdapterFactory(CoroutineCallAdapterFactory())        }.build()    }    private fun &lt;T&gt; getService(service: Class&lt;T&gt;): T {        return mRetrofit.create(service)    }    fun &lt;T&gt; handleResult(baseBean: BaseBean&lt;T&gt;, callback: CallBack&lt;T&gt;) {        //以http://www.wanandroid.com api例子，BaseBean根据自己实际情况定义，处理逻辑也        if (baseBean.errorCode != 0 || baseBean.data == null) {            //自定义异常            throw ServiceException(baseBean.errorCode, baseBean.errorMsg)        } else {            callback.onSuccess(baseBean.data)        }    }}</code></pre><p>ApiService在Retrofit使用中，需要定义ApiService接口。使用Kotlin协程时，返回值从Call变成了Deferred<t>。上篇博文中有讲到async/Deferred和launch/Job的区别就是acync/Deferred的挂起lambda函数会返回中Deferred<t>.await()会返回T的一个实例，而launch/Job中Job.join()没有返回值。所以Deferred<t>更适合开发中需要返回值的接口请求。</t></t></t></p><pre><code>/** * @author moodstrikerdd * @date 2018/4/19 * @label Retrofit Api */interface ApiService {    /**     * http://www.wanandroid.com     */    @GET(&quot;/friend/json&quot;)    fun getList(): Deferred&lt;BaseBean&lt;List&lt;HotWebBean&gt;&gt;&gt;}</code></pre><h3 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h3><pre><code> launch(UI) {            val deferred = async(CommonPool) {                RetrofitHelper.api.getList()            }            val await = deferred.await()            //处理数据        }</code></pre><p>看上去十分简洁，运行可以得到数据，但是在测试几次之后，发现当接口请求错误，或者内容不对使我们抛出自定异常之后，程序直接崩溃了。查看logcat可以看到当抛出异常的时候，我们这段请求逻辑并没有去try catch导致程序直接崩溃。所以还需要在请求逻辑上面添加try catch处理。</p><pre><code>  launch(UI) {           try {               val deferred = async(CommonPool) {                   RetrofitHelper.api.getList()               }               val await = deferred.await()               //处理数据           }catch (e:Exception){               e.printStackTrace()               //处理异常           }        }</code></pre><p><strong>这里抛出一个疑问，当我的try catch模块直接包含最外层的launch(UI)的时候，是不能捕获到异常的。具体我也没弄清楚原因是什么，只能推测可能是因为不能跨进程捕获异常</strong></p><h3 id="逻辑封装"><a href="#逻辑封装" class="headerlink" title="逻辑封装"></a>逻辑封装</h3><p>这里请求逻辑写好了，但是没有一套统一的回调方式来处理数据和处理异常，所以还需要定义一套回调接口，同时使用Kotlin的扩展函数做进一步的封装。部分代码如下,如需要看全部逻辑代码，可以直接去我的文章顶部的Github地址查看。</p><pre><code>fun &lt;T&gt; doHttp(createApi: () -&gt; Deferred&lt;BaseBean&lt;T&gt;&gt;, callBack: CallBack&lt;T&gt;) {    launch(UI) {        try {            val deferred = createApi()            val await = deferred.await()            RetrofitHelper.handleResult(await, callBack)        } catch (t: Throwable) {            callBack.onFailed(ExceptionHandle.handleException(t))        }    }}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> util </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin协程Api用例详解</title>
      <link href="/2018/04/26/kotlin-coroutines/"/>
      <url>/2018/04/26/kotlin-coroutines/</url>
      <content type="html"><![CDATA[<h3 id="Kotlin协程简述"><a href="#Kotlin协程简述" class="headerlink" title="Kotlin协程简述"></a>Kotlin协程简述</h3><p>开发中许多任务是需要长时间运行，并且需要调用者阻塞直到这些调用完成（比如网络 IO ，文件 IO ，CPU 或者 GPU 比较集中的工作）。在完成这些任务时我们也可以使用异步处理的方式，例如Rxjava。而协程提供了一种避免线程阻塞并且用一种更轻量级，更易操控到操作：协程暂停。</p><pre><code>//添加Kotlin协程依赖implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:0.22.5&quot;</code></pre><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>当一个函数被 suspend 修饰时表示可以被挂起，调用它会导致挂起协程，挂起函数可以和正常函数那样接受参数返回结果，但只能在协程中调用或着被其他挂起函数调用。</p><pre><code>suspend fun doSomething(){        //do something        delay(1000)    }</code></pre><p>因为delay为Kotlin封装的挂起函数，所以调用delay的函数也必须是挂起函数。</p><h3 id="协程Api"><a href="#协程Api" class="headerlink" title="协程Api"></a>协程Api</h3><p>在已有的Api中，Kotlin提供了两种方式实现协程 async/Deferred和launch/Job</p><pre><code>//async/Deferredpublic actual fun &lt;T&gt; async(    context: CoroutineContext = DefaultDispatcher,    start: CoroutineStart = CoroutineStart.DEFAULT,    parent: Job? = null,   &lt;strong&gt; block: suspend CoroutineScope.() -&gt; T&lt;/strong&gt;): Deferred&lt;T&gt; {    val newContext = newCoroutineContext(context, parent)    val coroutine = if (start.isLazy)        LazyDeferredCoroutine(newContext, block) else        DeferredCoroutine&lt;T&gt;(newContext, active = true)    coroutine.start(start, coroutine, block)    return coroutine}</code></pre><pre><code>//launch/Jobpublic expect fun launch(    context: CoroutineContext = DefaultDispatcher,    start: CoroutineStart = CoroutineStart.DEFAULT,    parent: Job? = null,   &lt;strong&gt; block: suspend CoroutineScope.() -&gt; Unit&lt;/strong&gt;): Job</code></pre><p>从源码中可以看出async和launch的参数列表中只有最后一个参数：带有 suspend 修饰的函数类型不同，async中的lambda有返回值，和Deferred的类型相同。launch中的lambda没有返回值。</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>两个Api的构造函数中，第一个参数为context。在android开发中比较常用的两个为UI何CommonPool。<br>UI为主线程，UI线程，只有context是UI的launch或者async的block lambda中才能更新UI<br>CommonPool为公共的线程池，在context是CommonPool的lauch或者async中的block lambda中可以异步处理耗时操作。</p><pre><code>launch(UI) {            text.setText(&quot;UI&quot;)        }async(UI) {            text.setText(&quot;UI&quot;)        }launch(CommonPool) {            delay(1000)        }async(CommonPool) {            delay(1000)        }</code></pre><h4 id="async-Deferred"><a href="#async-Deferred" class="headerlink" title="async/Deferred"></a>async/Deferred</h4><pre><code> async{            loge(message = &quot;outer start&quot;)            val inner = async{                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)                &quot;stop&quot;            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            val await = inner.await()            loge(message = &quot;outer stop&quot;)            await        }//        依次打印//        16:30:41.759 14668-14737/com.moo.demogo E/DemoGo: outer start//        16:30:41.761 14668-14737/com.moo.demogo E/DemoGo: outer wait itself start//        16:30:41.768 14668-14737/com.moo.demogo E/DemoGo: inner start//        16:30:42.268 14668-14738/com.moo.demogo E/DemoGo: outer wait itself stop//        16:30:42.268 14668-14738/com.moo.demogo E/DemoGo: outer wait inner//        16:30:42.771 14668-14738/com.moo.demogo E/DemoGo: inner stop//        16:30:42.772 14668-14738/com.moo.demogo E/DemoGo: outer stop</code></pre><p>从打印的信息可以看出outer（外层async）开始线性调用，打印outer start，在inner创建之后inner也开始执行，（outer wait itself start打印在inner start之前是因为inner async在创建的过程中会耗费极少的时间，而在这段时间内outer已经执行到下一步，理论上在inner创建之后，inner和outer之后都是同步执行）当outer等待500ms之后 outer打印outer wait itself stop同时开始等待inner，打印outer wait inner，下面这句代码val await = inner.await()为Kotlin协程重点。正常情况下，outer会直接打印outer stop，之后等待500ms之后 inner stop。但是由于inner.await(),outer会挂起，等待inner执行结束，返回字符串“stop”之后，outer再结束，这也就是为什么最后是outer wait inner500ms之后inner stop 然后才是outer stop</p><h4 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch/Job"></a>launch/Job</h4><pre><code>launch{            loge(message = &quot;outer start&quot;)            val inner = launch{                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            inner.join()            loge(message = &quot;outer stop&quot;)        }//        依次打印//        16:57:05.431 20131-20298/com.moo.demogo E/DemoGo: outer start//        16:57:05.432 20131-20298/com.moo.demogo E/DemoGo: outer wait itself start//        16:57:05.432 20131-20300/com.moo.demogo E/DemoGo: inner start//        16:57:05.940 20131-20298/com.moo.demogo E/DemoGo: outer wait itself stop//        16:57:05.940 20131-20298/com.moo.demogo E/DemoGo: outer wait inner//        16:57:06.439 20131-20298/com.moo.demogo E/DemoGo: inner stop//        16:57:06.441 20131-20300/com.moo.demogo E/DemoGo: outer stop</code></pre><p>打印信息和async/Deferred一致，区别在与lauch返回Job，挂起方法为job.join()且没有返回值。</p><p>async和launch可以根据是否需要返回值这一特点选择使用或者混合使用</p><pre><code>launch {            loge(message = &quot;outer start&quot;)            val inner = async {                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)                &quot;stop&quot;            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            val await = inner.await()            //deal result await            loge(message = &quot;outer stop&quot;)        }</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>源码分析SwipeRefreshLayout子View侧滑冲突（侧滑菜单ListView，ViewPager）</title>
      <link href="/2018/04/25/tips-swiperefreshlayout/"/>
      <url>/2018/04/25/tips-swiperefreshlayout/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间项目需要侧滑菜单的ListView，所以自己重写ListView仿qq的部分效果自定义了一个SideslipListView，在Dome里面运行正常，但是在使用的时候，发现经常侧滑有时候滑一半就失灵了，并且同时触发了SwipeRefreshLayout的下拉刷新CircleImageView的显示。反复试验了几次并配合log，得出问题：<strong>当SideslipListView到了顶部且侧滑的时候出现垂直方向滑动，会导致子View的滑动事件失效，SwipeRefreshLayout处理了滑动事件，显示顶部CircleImageView。</strong>因为我的SideslipListView是通过对触摸事件做处理实现侧滑的，所以我第一反应就是可能滑动冲突了。</p><h3 id="Android事件分发"><a href="#Android事件分发" class="headerlink" title="Android事件分发"></a>Android事件分发</h3><p><img src="/2018/04/25/tips-swiperefreshlayout/timg.jpg" alt=""><br>上面这张图相信所有人都烂熟于心了，简单分析可以知道SwipeRefreshLayout可能搞事情的地方是<strong>dispatchTouchEvent ，onInterceptTouchEvent</strong>。那就去看看源码中是如何实现。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>SwipeRefreshLayout继承自ViewGroup，在SwipeRefreshLayout中没有重写dispatchTouchEvent，只重写了 onInterceptTouchEvent，所以只用看在onInterceptTouchEvent中怎么处理的。<br><pre><code>@Override   public boolean onInterceptTouchEvent(MotionEvent ev) {       ensureTarget();       final int action = ev.getActionMasked();       int pointerIndex;       if (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) {           mReturningToStart = false;       }       if (!isEnabled() || mReturningToStart || canChildScrollUp()               || mRefreshing || mNestedScrollInProgress) {           &#x2F;&#x2F; Fail fast if we&#39;re not in a state where a swipe is possible           return false;       }       switch (action) {           case MotionEvent.ACTION_DOWN:               setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCircleView.getTop());               mActivePointerId = ev.getPointerId(0);               mIsBeingDragged = false;               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               mInitialDownY = ev.getY(pointerIndex);               break;           case MotionEvent.ACTION_MOVE:               if (mActivePointerId == INVALID_POINTER) {                   Log.e(LOG_TAG, &quot;Got ACTION_MOVE event but don&#39;t have an active pointer id.&quot;);                   return false;               }               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               final float y = ev.getY(pointerIndex);               startDragging(y);               break;           case MotionEvent.ACTION_POINTER_UP:               onSecondaryPointerUp(ev);               break;           case MotionEvent.ACTION_UP:           case MotionEvent.ACTION_CANCEL:               mIsBeingDragged = false;               mActivePointerId = INVALID_POINTER;               break;       }       return mIsBeingDragged;   }</code></pre><br>可以看到最终返回的是mIsBeingDragged的值，mIsBeingDragged表示SwipeRefreshLayout是否开始下拉刷新的操作，即SwipeRefreshLayout顶部的CircleImageView是否开始显示。mIsBeingDragged的值是true时，就会导致SwipeRefreshLayout的子View不能接受到相应的事件。</p><p>在分Action处理事件之前有一段代码</p><pre><code>if (!isEnabled() || mReturningToStart || canChildScrollUp()                || mRefreshing || mNestedScrollInProgress) {            // Fail fast if we&#39;re not in a state where a swipe is possible            return false;        }</code></pre><p>这段代码在SwipeRefreshLayout不可用，或者SwipeRefreshLayout的子View没有滑动到了顶部(其中ListView的判断是canChildScrollUp())的时候直接返回false，不拦截子view的触摸事件。这也就是为什么最开始产生的问题中，必须是SideSlipListView滑动到顶部的时候才会产生。</p><pre><code>public boolean canChildScrollUp() {    if (mChildScrollUpCallback != null) {        return mChildScrollUpCallback.canChildScrollUp(this, mTarget);    }    if (mTarget instanceof ListView) {        return ListViewCompat.canScrollList((ListView) mTarget, -1);    }    return mTarget.canScrollVertically(-1);}</code></pre><p>ACTION_DOWN ：mIsBeingDragged的第一次赋值在ACTION_DOWN中赋值为false，ACTION_DOWN中其他的代码都是初始化一些参数，可以略过。</p><p>ACTION_MOVE:在ACTION_MOVE中获取了触摸的Y坐标，然后调用了startDrag个ing（y）,跟踪过去。</p><pre><code>private void startDragging(float y) {       final float yDiff = y - mInitialDownY;       if (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) {           mInitialMotionY = mInitialDownY + mTouchSlop;           mIsBeingDragged = true;           mProgress.setAlpha(STARTING_PROGRESS_ALPHA);       }   }</code></pre><p>这里一目了然，把当前的y坐标和ACTION_DOWN中的起始y坐标求差，当Y轴的移动距离大于系统最小滑动距离的时候，会将mIsBeingDragged从false变成true,从而使onInterceptTouchEvent返回true，拦截子View的触摸事件。所以只要我们重写SwipeRefreshLayout的onInterceptTouchEvent方法，当滑动事件可判断为水平滑动的时候直接返回false，就可以解决SwipeRefreshLayout下子View的水平滑动冲突了。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code>/** * 是否让子view处理touch事件 */private boolean letChildDealTouchEvent;private float startX;private float startY;private int mTouchSlop;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) {    switch (ev.getAction()) {        case MotionEvent.ACTION_DOWN:            // 记录手指按下的位置            startY = ev.getY();            startX = ev.getX();            // 初始化标记            letChildDealTouchEvent = false;            break;        case MotionEvent.ACTION_MOVE:            // 如果子view正在拖拽中，那么不拦截它的事件，直接return false；            if (letChildDealTouchEvent) {                return false;            }            // 获取当前手指位置            float endY = ev.getY();            float endX = ev.getX();            float distanceX = Math.abs(endX - startX);            float distanceY = Math.abs(endY - startY);            // 如果X轴位移大于Y轴位移，那么将事件交给子View处理            if (distanceX &gt; mTouchSlop &amp;&amp; distanceX &gt; distanceY) {                letChildDealTouchEvent = true;                return false;            }            break;        case MotionEvent.ACTION_UP:        case MotionEvent.ACTION_CANCEL:            // 初始化标记            letChildDealTouchEvent = false;            break;        default:            break;    }    return super.onInterceptTouchEvent(ev);}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>当SwipeRefreshLayout可用且在子view滑动到顶部的时候，会对垂直方向的滑动事件做判断，当垂直方向向下的滑动距离大于系统最小滑动距离的时候，会拦截子View的Touch事件，开始做下拉刷新处理。重写SwipeRefreshLayout的onInterceptTouchEvent事件，对水平滑动做相应处理，可以避免该问题产生。 </strong></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
