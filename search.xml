<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>width-length-ems</title>
      <link href="/2018/05/02/width-length-ems/"/>
      <url>/2018/05/02/width-length-ems/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在DemoGo中自定义公共页面头部CommTopBar时，最开始没有限制title的长度、行数,导致在title过长时，会占满整个CommTopBar。而在TextView的文本限制中官方有3种方式，maxWidth、maxEms、maxLength。</p><h3 id="maxWidth"><a href="#maxWidth" class="headerlink" title="maxWidth"></a>maxWidth</h3><p>maxWidth，传入值为dimens，TextView layout_width必须为”wrap_content”,否则该属性失效。当TextView设置maxWidth属性之后，TextView的最大宽度固定，当TextView中文字长度大于TextView的宽度时，会换行。当打到maxLines之后,ellipsize会生效。</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxLines=&quot;2&quot;        android:maxWidth=&quot;100dp&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text1.png" alt=""></p><h3 id="maxLength"><a href="#maxLength" class="headerlink" title="maxLength"></a>maxLength</h3><p>maxLength,传入值为整形，TextView layout_width可以随意赋值。设置该属性之后TextView只会展示限制长度之内的text。</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxLines=&quot;1&quot;        android:maxLength=&quot;10&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text3.png" alt=""></p><h3 id="maxEms"><a href="#maxEms" class="headerlink" title="maxEms"></a>maxEms</h3><p>maxEms,传入值为整形，TextView layout_width必须为wrap_content。例如设置maxEms=”10”,相当于规定TextView最大宽度为10em的长度。em为一个是长度单位，是根据文字的size来决定。（详情可以参考<a href="https://en.wikipedia.org/wiki/Em_%28typography%29" target="_blank" rel="noopener">Em (typography)</a>）</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxEms=&quot;10&quot;        android:maxLines=&quot;2&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text2.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="限制TextView宽度方法"><a href="#限制TextView宽度方法" class="headerlink" title="限制TextView宽度方法"></a>限制TextView宽度方法</h4><p>1.直接限制TextView的layout_width,缺点：当文本未超出TextView的宽度时，TextView还是会占用相应大小。<br>2.maxWidth，maxWidth结合wrap_content使用，给TextView规定了最大宽度，未超过时TextView根据文本计算长度，超过时TextView宽度固定为最大宽度。<br>3.maxEms，maxEms和maxWidth相同，也是给TextView规定了最大宽度，和maxWidth的区别在于最大宽度的单位是em，而em的长度取决于字体大小。<br>4.maxLength，maxLength并不是处理TextView，而是处理设置的text，设置该属性，TextView只会展示限定范围内的text。</p><h4 id="ellipsize是否生效"><a href="#ellipsize是否生效" class="headerlink" title="ellipsize是否生效"></a>ellipsize是否生效</h4><p>1.TextView layout_width设置为固定宽度，无论是否设置maxWidth、maxEms或者maxLength，只要text文本超过了TextView的宽度和最大行数，ellipsize就会生效。<br>2.TextView layout_width设置为wrap_content，maxWidth、maxEms会使ellipsize生效，maxLength会使ellipsize失效。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit+Kotlin协程封装</title>
      <link href="/2018/04/26/retrofit-coroutines/"/>
      <url>/2018/04/26/retrofit-coroutines/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇博客<a href="http://moodstrikerdd.com/2018/04/26/kotlin-coroutines/" target="_blank" rel="noopener">Kotlin协程Api用例详解</a>中了解了Kotlin协程Api的使用。目前火热的Retrofit网络请求框架也支持了Kotlin协程，本篇博客中就</p><pre><code>//集成准备    //Kotlin协程    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:0.22.5&quot;    //okhttp log拦截器    implementation &#39;com.squareup.okhttp3:logging-interceptor:3.10.0&#39;    //Retrofit2    implementation &#39;com.squareup.retrofit2:retrofit:2.4.0&#39;    //Retrofit2 gson转换器    implementation &#39;com.squareup.retrofit2:converter-gson:2.4.0&#39;    //Retrofit2 协程适配器    implementation &#39;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-experimental-adapter:1.0.0&#39;</code></pre><h3 id="Retrofit2单例"><a href="#Retrofit2单例" class="headerlink" title="Retrofit2单例"></a>Retrofit2单例</h3><p>在Retrofit是用中，推荐使用单例封装，Kotlin中使用单例也非常方便，object为单例class，参数单例可用委托by lazy</p><pre><code>/** * @author moodstrikerdd * @date 2018/4/19 * @label 单例Retrofit Retrofit帮助类 */object RetrofitHelper {    private const val BASE_URL = &quot;http://www.wanandroid.com&quot;    private const val CONNECT_TIMEOUT = 30L    private const val READ_TIMEOUT = 10L    private const val TAG = &quot;Retrofit:&quot;    private const val DATA_FRONT = &quot;Data:&quot;    //实例化api    val api: ApiService by lazy {        getService(ApiService::class.java)    }    //实例化Gson，用于控制台格式化输出json    private val gson: Gson by lazy {        GsonBuilder().setPrettyPrinting().create()    }    //实例化Retrofit    private val mRetrofit: Retrofit by lazy {        Retrofit.Builder().apply {            baseUrl(BASE_URL)            client(OkHttpClient().newBuilder().apply {                connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS)                readTimeout(READ_TIMEOUT, TimeUnit.SECONDS)                addInterceptor {                    val request = it.request()                    val newBuilder = request.newBuilder()                    //请求预处理，此处没做处理                    it.proceed(newBuilder.build())                }                //log拦截器一定要最后添加，否则后面添加的拦截器修改的内容不会打印                addInterceptor(HttpLoggingInterceptor(HttpLoggingInterceptor.Logger {                    loge(TAG, if (it.startsWith(&quot;{&quot;)) {                        //控制台格式化输出json                        val fromJson = gson.fromJson(it, Any::class.java)                        DATA_FRONT + gson.toJson(fromJson)                    } else {                        DATA_FRONT + it                    })                }))            }.build())                    //添加gson转换器                    .addConverterFactory(GsonConverterFactory.create())                    //添加Kotlin 协程适配器                    .addCallAdapterFactory(CoroutineCallAdapterFactory())        }.build()    }    private fun &lt;T&gt; getService(service: Class&lt;T&gt;): T {        return mRetrofit.create(service)    }    fun &lt;T&gt; handleResult(baseBean: BaseBean&lt;T&gt;, callback: CallBack&lt;T&gt;) {        //以http://www.wanandroid.com api例子，BaseBean根据自己实际情况定义，处理逻辑也        if (baseBean.errorCode != 0 || baseBean.data == null) {            //自定义异常            throw ServiceException(baseBean.errorCode, baseBean.errorMsg)        } else {            callback.onSuccess(baseBean.data)        }    }}</code></pre><p>ApiService在Retrofit使用中，需要定义ApiService接口。使用Kotlin协程时，返回值从Call变成了Deferred<t>。上篇博文中有讲到async/Deferred和launch/Job的区别就是acync/Deferred的挂起lambda函数会返回中Deferred<t>.await()会返回T的一个实例，而launch/Job中Job.join()没有返回值。所以Deferred<t>更适合开发中需要返回值的接口请求。</t></t></t></p><pre><code>/** * @author moodstrikerdd * @date 2018/4/19 * @label Retrofit Api */interface ApiService {    /**     * http://www.wanandroid.com     */    @GET(&quot;/friend/json&quot;)    fun getList(): Deferred&lt;BaseBean&lt;List&lt;HotWebBean&gt;&gt;&gt;}</code></pre><h3 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h3><pre><code> launch(UI) {            val deferred = async(CommonPool) {                RetrofitHelper.api.getList()            }            val await = deferred.await()            //处理数据        }</code></pre><p>看上去十分简洁，运行可以得到数据，但是在测试几次之后，发现当接口请求错误，或者内容不对使我们抛出自定异常之后，程序直接崩溃了。查看logcat可以看到当抛出异常的时候，我们这段请求逻辑并没有去try catch导致程序直接崩溃。所以还需要在请求逻辑上面添加try catch处理。</p><pre><code>  launch(UI) {           try {               val deferred = async(CommonPool) {                   RetrofitHelper.api.getList()               }               val await = deferred.await()               //处理数据           }catch (e:Exception){               e.printStackTrace()               //处理异常           }        }</code></pre><p><strong>这里抛出一个疑问，当我的try catch模块直接包含最外层的launch(UI)的时候，是不能捕获到异常的。具体我也没弄清楚原因是什么，只能推测可能是因为不能跨进程捕获异常</strong></p><h3 id="逻辑封装"><a href="#逻辑封装" class="headerlink" title="逻辑封装"></a>逻辑封装</h3><p>这里请求逻辑写好了，但是没有一套统一的回调方式来处理数据和处理异常，所以还需要定义一套回调接口，同时使用Kotlin的扩展函数做进一步的封装。部分代码如下,如需要看全部逻辑代码，可以直接去我的文章顶部的Github地址查看。</p><pre><code>fun &lt;T&gt; doHttp(createApi: () -&gt; Deferred&lt;BaseBean&lt;T&gt;&gt;, callBack: CallBack&lt;T&gt;) {    launch(UI) {        try {            val deferred = createApi()            val await = deferred.await()            RetrofitHelper.handleResult(await, callBack)        } catch (t: Throwable) {            callBack.onFailed(ExceptionHandle.handleException(t))        }    }}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> util </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin协程Api用例详解</title>
      <link href="/2018/04/26/kotlin-coroutines/"/>
      <url>/2018/04/26/kotlin-coroutines/</url>
      <content type="html"><![CDATA[<h3 id="Kotlin协程简述"><a href="#Kotlin协程简述" class="headerlink" title="Kotlin协程简述"></a>Kotlin协程简述</h3><p>开发中许多任务是需要长时间运行，并且需要调用者阻塞直到这些调用完成（比如网络 IO ，文件 IO ，CPU 或者 GPU 比较集中的工作）。在完成这些任务时我们也可以使用异步处理的方式，例如Rxjava。而协程提供了一种避免线程阻塞并且用一种更轻量级，更易操控到操作：协程暂停。</p><pre><code>//添加Kotlin协程依赖implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:0.22.5&quot;</code></pre><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>当一个函数被 suspend 修饰时表示可以被挂起，调用它会导致挂起协程，挂起函数可以和正常函数那样接受参数返回结果，但只能在协程中调用或着被其他挂起函数调用。</p><pre><code>suspend fun doSomething(){        //do something        delay(1000)    }</code></pre><p>因为delay为Kotlin封装的挂起函数，所以调用delay的函数也必须是挂起函数。</p><h3 id="协程Api"><a href="#协程Api" class="headerlink" title="协程Api"></a>协程Api</h3><p>在已有的Api中，Kotlin提供了两种方式实现协程 async/Deferred和launch/Job</p><pre><code>//async/Deferredpublic actual fun &lt;T&gt; async(    context: CoroutineContext = DefaultDispatcher,    start: CoroutineStart = CoroutineStart.DEFAULT,    parent: Job? = null,   &lt;strong&gt; block: suspend CoroutineScope.() -&gt; T&lt;/strong&gt;): Deferred&lt;T&gt; {    val newContext = newCoroutineContext(context, parent)    val coroutine = if (start.isLazy)        LazyDeferredCoroutine(newContext, block) else        DeferredCoroutine&lt;T&gt;(newContext, active = true)    coroutine.start(start, coroutine, block)    return coroutine}</code></pre><pre><code>//launch/Jobpublic expect fun launch(    context: CoroutineContext = DefaultDispatcher,    start: CoroutineStart = CoroutineStart.DEFAULT,    parent: Job? = null,   &lt;strong&gt; block: suspend CoroutineScope.() -&gt; Unit&lt;/strong&gt;): Job</code></pre><p>从源码中可以看出async和launch的参数列表中只有最后一个参数：带有 suspend 修饰的函数类型不同，async中的lambda有返回值，和Deferred的类型相同。launch中的lambda没有返回值。</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>两个Api的构造函数中，第一个参数为context。在android开发中比较常用的两个为UI何CommonPool。<br>UI为主线程，UI线程，只有context是UI的launch或者async的block lambda中才能更新UI<br>CommonPool为公共的线程池，在context是CommonPool的lauch或者async中的block lambda中可以异步处理耗时操作。</p><pre><code>launch(UI) {            text.setText(&quot;UI&quot;)        }async(UI) {            text.setText(&quot;UI&quot;)        }launch(CommonPool) {            delay(1000)        }async(CommonPool) {            delay(1000)        }</code></pre><h4 id="async-Deferred"><a href="#async-Deferred" class="headerlink" title="async/Deferred"></a>async/Deferred</h4><pre><code> async{            loge(message = &quot;outer start&quot;)            val inner = async{                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)                &quot;stop&quot;            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            val await = inner.await()            loge(message = &quot;outer stop&quot;)            await        }//        依次打印//        16:30:41.759 14668-14737/com.moo.demogo E/DemoGo: outer start//        16:30:41.761 14668-14737/com.moo.demogo E/DemoGo: outer wait itself start//        16:30:41.768 14668-14737/com.moo.demogo E/DemoGo: inner start//        16:30:42.268 14668-14738/com.moo.demogo E/DemoGo: outer wait itself stop//        16:30:42.268 14668-14738/com.moo.demogo E/DemoGo: outer wait inner//        16:30:42.771 14668-14738/com.moo.demogo E/DemoGo: inner stop//        16:30:42.772 14668-14738/com.moo.demogo E/DemoGo: outer stop</code></pre><p>从打印的信息可以看出outer（外层async）开始线性调用，打印outer start，在inner创建之后inner也开始执行，（outer wait itself start打印在inner start之前是因为inner async在创建的过程中会耗费极少的时间，而在这段时间内outer已经执行到下一步，理论上在inner创建之后，inner和outer之后都是同步执行）当outer等待500ms之后 outer打印outer wait itself stop同时开始等待inner，打印outer wait inner，下面这句代码val await = inner.await()为Kotlin协程重点。正常情况下，outer会直接打印outer stop，之后等待500ms之后 inner stop。但是由于inner.await(),outer会挂起，等待inner执行结束，返回字符串“stop”之后，outer再结束，这也就是为什么最后是outer wait inner500ms之后inner stop 然后才是outer stop</p><h4 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch/Job"></a>launch/Job</h4><pre><code>launch{            loge(message = &quot;outer start&quot;)            val inner = launch{                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            inner.join()            loge(message = &quot;outer stop&quot;)        }//        依次打印//        16:57:05.431 20131-20298/com.moo.demogo E/DemoGo: outer start//        16:57:05.432 20131-20298/com.moo.demogo E/DemoGo: outer wait itself start//        16:57:05.432 20131-20300/com.moo.demogo E/DemoGo: inner start//        16:57:05.940 20131-20298/com.moo.demogo E/DemoGo: outer wait itself stop//        16:57:05.940 20131-20298/com.moo.demogo E/DemoGo: outer wait inner//        16:57:06.439 20131-20298/com.moo.demogo E/DemoGo: inner stop//        16:57:06.441 20131-20300/com.moo.demogo E/DemoGo: outer stop</code></pre><p>打印信息和async/Deferred一致，区别在与lauch返回Job，挂起方法为job.join()且没有返回值。</p><p>async和launch可以根据是否需要返回值这一特点选择使用或者混合使用</p><pre><code>launch {            loge(message = &quot;outer start&quot;)            val inner = async {                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)                &quot;stop&quot;            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            val await = inner.await()            //deal result await            loge(message = &quot;outer stop&quot;)        }</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>源码分析SwipeRefreshLayout子View侧滑冲突（侧滑菜单ListView，ViewPager）</title>
      <link href="/2018/04/25/tips-swiperefreshlayout/"/>
      <url>/2018/04/25/tips-swiperefreshlayout/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间项目需要侧滑菜单的ListView，所以自己重写ListView仿qq的部分效果自定义了一个SideslipListView，在Dome里面运行正常，但是在使用的时候，发现经常侧滑有时候滑一半就失灵了，并且同时触发了SwipeRefreshLayout的下拉刷新CircleImageView的显示。反复试验了几次并配合log，得出问题：<strong>当SideslipListView到了顶部且侧滑的时候出现垂直方向滑动，会导致子View的滑动事件失效，SwipeRefreshLayout处理了滑动事件，显示顶部CircleImageView。</strong>因为我的SideslipListView是通过对触摸事件做处理实现侧滑的，所以我第一反应就是可能滑动冲突了。</p><h3 id="Android事件分发"><a href="#Android事件分发" class="headerlink" title="Android事件分发"></a>Android事件分发</h3><p><div align="center"><img src="https://img-blog.csdn.net/20180411112342276"></div><br>上面这张图相信所有人都烂熟于心了，简单分析可以知道SwipeRefreshLayout可能搞事情的地方是<strong>dispatchTouchEvent ，onInterceptTouchEvent</strong>。那就去看看源码中是如何实现。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>SwipeRefreshLayout继承自ViewGroup，在SwipeRefreshLayout中没有重写dispatchTouchEvent，只重写了 onInterceptTouchEvent，所以只用看在onInterceptTouchEvent中怎么处理的。<br><pre><code>@Override   public boolean onInterceptTouchEvent(MotionEvent ev) {       ensureTarget();       final int action = ev.getActionMasked();       int pointerIndex;       if (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) {           mReturningToStart = false;       }       if (!isEnabled() || mReturningToStart || canChildScrollUp()               || mRefreshing || mNestedScrollInProgress) {           &#x2F;&#x2F; Fail fast if we&#39;re not in a state where a swipe is possible           return false;       }       switch (action) {           case MotionEvent.ACTION_DOWN:               setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCircleView.getTop());               mActivePointerId = ev.getPointerId(0);               mIsBeingDragged = false;               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               mInitialDownY = ev.getY(pointerIndex);               break;           case MotionEvent.ACTION_MOVE:               if (mActivePointerId == INVALID_POINTER) {                   Log.e(LOG_TAG, &quot;Got ACTION_MOVE event but don&#39;t have an active pointer id.&quot;);                   return false;               }               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               final float y = ev.getY(pointerIndex);               startDragging(y);               break;           case MotionEvent.ACTION_POINTER_UP:               onSecondaryPointerUp(ev);               break;           case MotionEvent.ACTION_UP:           case MotionEvent.ACTION_CANCEL:               mIsBeingDragged = false;               mActivePointerId = INVALID_POINTER;               break;       }       return mIsBeingDragged;   }</code></pre><br>可以看到最终返回的是mIsBeingDragged的值，mIsBeingDragged表示SwipeRefreshLayout是否开始下拉刷新的操作，即SwipeRefreshLayout顶部的CircleImageView是否开始显示。mIsBeingDragged的值是true时，就会导致SwipeRefreshLayout的子View不能接受到相应的事件。</p><p>在分Action处理事件之前有一段代码</p><pre><code>if (!isEnabled() || mReturningToStart || canChildScrollUp()                || mRefreshing || mNestedScrollInProgress) {            // Fail fast if we&#39;re not in a state where a swipe is possible            return false;        }</code></pre><p>这段代码在SwipeRefreshLayout不可用，或者SwipeRefreshLayout的子View没有滑动到了顶部(其中ListView的判断是canChildScrollUp())的时候直接返回false，不拦截子view的触摸事件。这也就是为什么最开始产生的问题中，必须是SideSlipListView滑动到顶部的时候才会产生。</p><pre><code>public boolean canChildScrollUp() {    if (mChildScrollUpCallback != null) {        return mChildScrollUpCallback.canChildScrollUp(this, mTarget);    }    if (mTarget instanceof ListView) {        return ListViewCompat.canScrollList((ListView) mTarget, -1);    }    return mTarget.canScrollVertically(-1);}</code></pre><p>ACTION_DOWN ：mIsBeingDragged的第一次赋值在ACTION_DOWN中赋值为false，ACTION_DOWN中其他的代码都是初始化一些参数，可以略过。</p><p>ACTION_MOVE:在ACTION_MOVE中获取了触摸的Y坐标，然后调用了startDrag个ing（y）,跟踪过去。</p><pre><code>private void startDragging(float y) {       final float yDiff = y - mInitialDownY;       if (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) {           mInitialMotionY = mInitialDownY + mTouchSlop;           mIsBeingDragged = true;           mProgress.setAlpha(STARTING_PROGRESS_ALPHA);       }   }</code></pre><p>这里一目了然，把当前的y坐标和ACTION_DOWN中的起始y坐标求差，当Y轴的移动距离大于系统最小滑动距离的时候，会将mIsBeingDragged从false变成true,从而使onInterceptTouchEvent返回true，拦截子View的触摸事件。所以只要我们重写SwipeRefreshLayout的onInterceptTouchEvent方法，当滑动事件可判断为水平滑动的时候直接返回false，就可以解决SwipeRefreshLayout下子View的水平滑动冲突了。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code>/** * 是否让子view处理touch事件 */private boolean letChildDealTouchEvent;private float startX;private float startY;private int mTouchSlop;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) {    switch (ev.getAction()) {        case MotionEvent.ACTION_DOWN:            // 记录手指按下的位置            startY = ev.getY();            startX = ev.getX();            // 初始化标记            letChildDealTouchEvent = false;            break;        case MotionEvent.ACTION_MOVE:            // 如果子view正在拖拽中，那么不拦截它的事件，直接return false；            if (letChildDealTouchEvent) {                return false;            }            // 获取当前手指位置            float endY = ev.getY();            float endX = ev.getX();            float distanceX = Math.abs(endX - startX);            float distanceY = Math.abs(endY - startY);            // 如果X轴位移大于Y轴位移，那么将事件交给子View处理            if (distanceX &gt; mTouchSlop &amp;&amp; distanceX &gt; distanceY) {                letChildDealTouchEvent = true;                return false;            }            break;        case MotionEvent.ACTION_UP:        case MotionEvent.ACTION_CANCEL:            // 初始化标记            letChildDealTouchEvent = false;            break;        default:            break;    }    return super.onInterceptTouchEvent(ev);}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>当SwipeRefreshLayout可用且在子view滑动到顶部的时候，会对垂直方向的滑动事件做判断，当垂直方向向下的滑动距离大于系统最小滑动距离的时候，会拦截子View的Touch事件，开始做下拉刷新处理。重写SwipeRefreshLayout的onInterceptTouchEvent事件，对水平滑动做相应处理，可以避免该问题产生。 </strong></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
