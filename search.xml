<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>WebView POST封装</title>
      <link href="/2018/07/20/WebView-POST%E5%B0%81%E8%A3%85/"/>
      <url>/2018/07/20/WebView-POST%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。】</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在最近的开发中碰到了一下运用场景，当调用第三方的银行合作接口之后，app需要跳转到第三方银行的H5页面进行操作，本以为<br>银行的接口会返回一个url然后通过get方式将app中的参数传给第三方H5。但是接口返回的是一个url和一个密文参数，由于安全性，<br>银行的H5需要通过用POST请求将参数带入从而展示页面，碍于以前没有接触，下意识的以为Android的WebView不能实现，查阅过一些资料之后发现Android的WebView是可以通过POST请求<br>的方式打开相应的网页。</p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><pre><code> //GET方式请求网页 public void loadUrl(String url) //POST方式请求网页（若url不是http或者https链接，还是会调用GET请求方式） public void postUrl(String url, byte[] postData) //调用方法  val url = &quot;https://aaa...&quot;;  val param = &quot;abcd&quot;;  //根据需求是否需要将参数加密，如Base64加密  param = Base64.encode(param.toByteArray(), Base64.DEFAULT).toString(Charsets.UTF_8)  //因为在网络传输过程中有特殊符号会自动被转义，例如‘+’等需要将参数编码后传输  val paramString = &quot;key=&quot;+URLEncoder.encode(param, &quot;UTF-8&quot;)  //url 和 params都准备好之后，就可以处理请求  webView.poutUrl(url,paramString.toByteArray())</code></pre><h3 id="请求封装"><a href="#请求封装" class="headerlink" title="请求封装"></a>请求封装</h3><p>通用WebView中需要满足GET和POST两种请求方式，所以在转到WebView的activity中时需要传POST和GET的标记量，<br>参数由于可能有多个的情况，所以WebView中需要用Map&lt;String,String&gt;接收。<br>核心代码：</p><pre><code>companion object {    fun intentStart(context: Context, url: String, title: String?) {        val intent = Intent(context, WebViewActivity::class.java)        intent.putExtra(DefineKey.URL, url)        intent.putExtra(DefineKey.TITLE, title ?: &quot;网页&quot;)        context.startActivity(intent)    }    fun intentStart(context: Context, url: String, title: String?, params: HashMap&lt;String, String&gt;) {        val intent = Intent(context, WebViewActivity::class.java)        intent.putExtra(DefineKey.USE_POST, true)        intent.putExtra(DefineKey.URL, url)        intent.putExtra(DefineKey.TITLE, title ?: &quot;网页&quot;)        intent.putExtra(DefineKey.PARAMS_MAP, params)        context.startActivity(intent)    }}if (usePost) {    val sb = StringBuilder()    params.forEach { key, value -&gt;        sb.append(&quot;$key=${URLEncoder.encode(value, &quot;UTF-8&quot;)}&quot;)    }    webView.postUrl(url, sb.toString().toByteArray())} else {    webView.loadUrl(url)}</code></pre><h3 id="使用POST的问题"><a href="#使用POST的问题" class="headerlink" title="使用POST的问题"></a>使用POST的问题</h3><p>在成功使用POST去请求加载出页面只有，发现的新的问题：在第一个页面中输入相关信息，点击跳转到了下一个网页，再点返回<br>键的时候第一个界面会加载失败，原因肯定是返回时第一个界面重新加载了，给WebView加上缓存，会发现缓存在POST请求的时候<br>并不会生效。解决方式：</p><p>在一开始加载的时候我们定义了一个布尔值 userPost表示当前界面是不是使用POST请求，那么在shouldOverrideUrlLoading中<br>就可以根据这个变量使后面的url跳转到一个新的Activity去处理</p><pre><code>  if (usePost) {    WebViewActivity.intentStart(this, url, null)    return true  }  return false</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>6.0和8.0运行时权限处理</title>
      <link href="/2018/06/05/runtime-permission/"/>
      <url>/2018/06/05/runtime-permission/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Android 6.0 SDK 23的时候，google为了安全推出了运行时权限，控制app对用户手机权限的获取。在Android 8.0 SDK 26的时候，google进一步的优化了运行时权限。</p><h3 id="6-0运行时权限"><a href="#6-0运行时权限" class="headerlink" title="6.0运行时权限"></a>6.0运行时权限</h3><h4 id="运行时权限简介"><a href="#运行时权限简介" class="headerlink" title="运行时权限简介"></a>运行时权限简介</h4><p>在6.0以前，即targetSdkVersion &lt; 23时，app获取用户手机权限，只需要在AndroidManifest.xml文件中声明相应权限即可，如：</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</code></pre><p>而在6.0以后，想要获取某些敏感权限不仅仅需要在AndroidManifest.xml文件中声明，还要通过运行时权限Api去动态获取，用户可以根据具体使用情况授权相应权限或者拒绝相应授权。</p><h4 id="敏感权限"><a href="#敏感权限" class="headerlink" title="敏感权限"></a>敏感权限</h4><p>google官方文档上有相应表格显示哪些是敏感权限，即需要兼容运行时权限的权限和权限组。<br><img src="/2018/06/05/runtime-permission/permissions.png" alt=""></p><h4 id="运行时权限Api"><a href="#运行时权限Api" class="headerlink" title="运行时权限Api"></a>运行时权限Api</h4><p>关于运行时权限，在support包中的ActivityCompat中提供了相应的Api</p><pre><code>public static int checkSelfPermission(@NonNull Context context, @NonNull String permission)public static void requestPermissions(final @NonNull Activity activity,            final @NonNull String[] permissions, final @IntRange(from = 0) int requestCode)public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,            @NonNull int[] grantResults)public static boolean shouldShowRequestPermissionRationale(@NonNull Activity activity,            @NonNull String permission)</code></pre><p><strong>checkSelfPermission</strong>：检查app是否已经被授权了某个权限，一般在请求权限之前调用。</p><p>   android.content.pm.PackageManager#PERMISSION_GRANTED 已经授权 </p><p>   android.content.pm.PackageManager#PERMISSION_DENIED 没有授权<br><strong>requestPermission</strong>：请求权限，可同时请求多个。当用户已经拒绝过该权限切选择了不再提醒 requestPermission将不会获取权限<br><strong>onRequestPermissionsResult</strong>：Activity中请求权限的结果回调<br><strong>shouldShowRequestPermissionRationale</strong>字面意思是是否应该显示请求权限的根据，在使用中有以下情况</p><p>   1.没有请求该权限之前，返回false</p><p>   2.请求拒绝该权限，但是没有选择不再提醒，返回true</p><p>   3.请求拒绝该权限，选择不再提醒，返回false（不再提醒选项一般第二次请求的时候出现）</p><h4 id="运行时权限封装"><a href="#运行时权限封装" class="headerlink" title="运行时权限封装"></a>运行时权限封装</h4><pre><code>/** * @author moodstrikerdd * @date 2018/5/31 * @label 运行时权限帮助类 */object RuntimePermissionHelper {    val permissions = arrayListOf&lt;String&gt;()    private val permissionNotAllowed = arrayListOf&lt;String&gt;()    private const val REQUEST_CODE_PERMISSION = 1001    private var requestCode = 0    /**     * 检查相应权限是否已经获取，没获取的权限放入permissionNotAllowed List中     */    fun checkPermissions(activity: Activity): Boolean {        if (Build.VERSION.SDK_INT &lt; 23) {            return true        }        permissionNotAllowed.clear()        permissions.forEach {            if (ActivityCompat.checkSelfPermission(activity, it) != PackageManager.PERMISSION_GRANTED) {                permissionNotAllowed.add(it)            }        }        return permissionNotAllowed.isEmpty()    }    /**     * 方式一 请求权限     * 先判断shouldShowRequestPermissionRationale，根据返回值决定是跳转设置界面还是请求权限     */    fun requestPermissions(activity: Activity, requestCode: Int = REQUEST_CODE_PERMISSION) {        if (Build.VERSION.SDK_INT &lt; 23) {            return        }        for (i in 0 until permissionNotAllowed.size) {            val shouldShow = ActivityCompat.shouldShowRequestPermissionRationale(activity, permissionNotAllowed[i])            val requested = SPUtils.get(permissionNotAllowed[i], false) as Boolean            if (requested &amp;&amp; !shouldShow) {                AlertDialog.Builder(activity)                        .setTitle(&quot;提示&quot;)                        .setMessage(&quot;当前应用缺少权限:${Permission.getPermissionName(permissionNotAllowed.toTypedArray())}。请点击\&quot;设置\&quot;,\&quot;权限\&quot;打开相应权限&quot;)                        .setPositiveButton(&quot;设置&quot;) { _, _ -&gt; AppUtils.getAppDetailSettingIntent(activity) }                        .setNegativeButton(&quot;取消&quot;) { dialog, _ -&gt; dialog.dismiss() }                        .create()                        .show()                return            }        }        RuntimePermissionHelper.requestCode = requestCode        permissionNotAllowed.forEach { SPUtils.put(it, true) }        ActivityCompat.requestPermissions(activity, permissionNotAllowed.toTypedArray(), requestCode)    }    /**     * 方式二 请求权限     * 直接请求未授权的权限     */    fun requestPermissions2(activity: Activity, requestCode: Int = REQUEST_CODE_PERMISSION) {        if (Build.VERSION.SDK_INT &lt; 23) {            return        }        RuntimePermissionHelper.requestCode = requestCode        permissionNotAllowed.forEach { SPUtils.put(it, true) }        ActivityCompat.requestPermissions(activity, permissionNotAllowed.toTypedArray(), requestCode)    }    /**     * 方式二 直接请求所有权限     */    fun requestPermissionsWithoutCheck(activity: Activity, requestCode: Int = REQUEST_CODE_PERMISSION) {        if (Build.VERSION.SDK_INT &lt; 23) {            return        }        RuntimePermissionHelper.requestCode = requestCode        ActivityCompat.requestPermissions(activity, permissions.toTypedArray(), requestCode)    }    /**     * 方式一 结果回调 只存在 获取权限失败和成功     */    fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray, success: (requestCode: Int) -&gt; Unit) {        if (requestCode == RuntimePermissionHelper.requestCode) {            for (i in 0 until permissions.size) {                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {                    toast(message = &quot;必须同意所有该类权限才能使用本程序&quot;)                    return                }            }            success(requestCode)        }    }    /**     * 方式二 结果回调     * 在回调结果中判断 shouldShowRequestPermissionRationale     * 三种结果     * 1.提示获取权限失败     * 2.跳转设置界面     * 3.获取权限成功     */    fun onRequestPermissionsResult2(activity: Activity, requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray, success: (requestCode: Int) -&gt; Unit) {        if (requestCode == RuntimePermissionHelper.requestCode) {            val permissionsNotAllowed = permissions.filterIndexed { index, _ -&gt;                grantResults[index] != PackageManager.PERMISSION_GRANTED            }            for (i in 0 until permissions.size) {                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {                    if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permissions[i])) {                        toast(message = &quot;必须同意${Permission.getPermissionName(permissionsNotAllowed.toTypedArray())}权限才能使                    } else {                        AlertDialog.Builder(activity)                                .setTitle(&quot;提示&quot;)                                .setMessage(&quot;当前应用缺少权限:${Permission.getPermissionName(permissionsNotAllowed.toTypedArray())}。请点击\&quot;设置\&quot;,\&quot;权限\&quot;打开相应权限&quot;)                                .setPositiveButton(&quot;设置&quot;) { _, _ -&gt; AppUtils.getAppDetailSettingIntent(activity) }                                .setNegativeButton(&quot;取消&quot;) { dialog, _ -&gt; dialog.dismiss() }                                .create()                                .show()                    }                    return                }            }            success(requestCode)        }    }}</code></pre><p>区别在于shouldShowRequestPermissionRationale的调用位置<br>1.在请求权限之前调用，当shouldShowRequestPermissionRationale返回false的时候跳转设置界面，返回true的时候调用requestPermissions请求权限<br>shouldShowRequestPermissionRationale返回false跳转设置界面是因为此时requestPermission已经不能获取权限，但是返回false的时候会有一个特殊情况就是当还未请求权限时，<br>因此需要通过SharedPreferences记录是否已经请求过该权限。在还未请求过时，请求权限，已经请求过的同时shouldShowRequestPermissionRationale发挥false的时候跳转到设置界面</p><pre><code>for (i in 0 until permissionNotAllowed.size) {            val shouldShow = ActivityCompat.shouldShowRequestPermissionRationale(activity, permissionNotAllowed[i])            val requested = SPUtils.get(permissionNotAllowed[i], false) as Boolean            if (requested &amp;&amp; !shouldShow) {                //TODO 跳转设置界面                return            }        }        RuntimePermissionHelper.requestCode = requestCode        //可请求权限，并让请求的权限标记为已请求        permissionNotAllowed.forEach { SPUtils.put(it, true) }        ActivityCompat.requestPermissions(activity, permissionNotAllowed.toTypedArray(), requestCode)</code></pre><p>2.在返回结果中调用，这种方式是为了避免还未请求时shouldShowRequestPermissionRationale返回false的特殊情况。<br>在请求权限失败的时候判断shouldShowRequestPermissionRationale的返回值，返回true的时候提示获取权限失败，false的时候跳转到设置界面。</p><pre><code>fun onRequestPermissionsResult2(activity: Activity, requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray, success: (requestCode: Int) -&gt; Unit) {        if (requestCode == RuntimePermissionHelper.requestCode) {            val permissionsNotAllowed = permissions.filterIndexed { index, _ -&gt;                grantResults[index] != PackageManager.PERMISSION_GRANTED            }            for (i in 0 until permissions.size) {                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {                    if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permissions[i])) {                        toast(message = &quot;必须同意${Permission.getPermissionName(permissionsNotAllowed.toTypedArray())}权限才能使                    } else {                       //TODO 跳转设置界面                    }                    return                }            }            success(requestCode)        }    }</code></pre><h3 id="8-0运行时权限"><a href="#8-0运行时权限" class="headerlink" title="8.0运行时权限"></a>8.0运行时权限</h3><p>在6.0到8.0之间的版本中，在运行时权限申请时，授权了组中的一个权限，会同时授权权限组中其他所有权限。而在8.0及以上版本中授权组中的一个权限，并不同时授权组中其他的权限，但是当你再次请求组中其他权限的时候，会直接授权，不需要用户选择。<br>例如 Manifest.permission.READ_EXTERNAL_STORAGE和Manifest.permission.WRITE_EXTERNAL_STORAGE，在6.0~8.0之间只需请求其中一个，另一个就会同时授权，而在8.0以上，授权了其中一个，当需要另一个权限的时候需要再次手动调用requestPermission，否则不会获的授权。<br>适配方式：<br>        1.请求权限时，将同组的权限全部请求授权。<br>        2.在每个需要权限的地方，都去申请相关权限。</p><pre><code>/** * @author moodstrikerdd * @date 2018/5/31 * @label 6.0运行时权限 */object Permission {    /**     *读写日历。     */    val CALENDAR: Array&lt;String&gt;    /**     * 相机。     */    val CAMERA: Array&lt;String&gt;    /**     * 读写联系人。     */    val CONTACTS: Array&lt;String&gt;    /**     * 读位置信息。     */    val LOCATION: Array&lt;String&gt;    /**     * 使用麦克风。     */    val MICROPHONE: Array&lt;String&gt;    /**     * 读电话状态、打电话、读写电话记录。     */    val PHONE: Array&lt;String&gt;    /**     * 传感器。     */    val SENSORS: Array&lt;String&gt;    /**     * 读写短信、收发短信。     */    val SMS: Array&lt;String&gt;    /**     * 读写存储卡。     */    val STORAGE: Array&lt;String&gt;    init {        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) {            CALENDAR = arrayOf()            CAMERA = arrayOf()            CONTACTS = arrayOf()            LOCATION = arrayOf()            MICROPHONE = arrayOf()            PHONE = arrayOf()            SENSORS = arrayOf()            SMS = arrayOf()            STORAGE = arrayOf()        } else {            CALENDAR = arrayOf(                    Manifest.permission.READ_CALENDAR,                    Manifest.permission.WRITE_CALENDAR)            CAMERA = arrayOf(                    Manifest.permission.CAMERA)            CONTACTS = arrayOf(                    Manifest.permission.READ_CONTACTS,                    Manifest.permission.WRITE_CONTACTS,                    Manifest.permission.GET_ACCOUNTS)            LOCATION = arrayOf(                    Manifest.permission.ACCESS_FINE_LOCATION,                    Manifest.permission.ACCESS_COARSE_LOCATION)            MICROPHONE = arrayOf(                    Manifest.permission.RECORD_AUDIO)            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {                PHONE = arrayOf(                        Manifest.permission.READ_PHONE_STATE,                        Manifest.permission.READ_PHONE_NUMBERS,                        Manifest.permission.ANSWER_PHONE_CALLS,                        Manifest.permission.ADD_VOICEMAIL,                        Manifest.permission.CALL_PHONE,                        Manifest.permission.READ_CALL_LOG,                        Manifest.permission.WRITE_CALL_LOG,                        Manifest.permission.USE_SIP,                        Manifest.permission.PROCESS_OUTGOING_CALLS)            } else {                PHONE = arrayOf(                        Manifest.permission.READ_PHONE_STATE,                        Manifest.permission.ADD_VOICEMAIL,                        Manifest.permission.CALL_PHONE,                        Manifest.permission.READ_CALL_LOG,                        Manifest.permission.WRITE_CALL_LOG,                        Manifest.permission.USE_SIP,                        Manifest.permission.PROCESS_OUTGOING_CALLS)            }            SENSORS = arrayOf(                    Manifest.permission.BODY_SENSORS)            SMS = arrayOf(                    Manifest.permission.SEND_SMS,                    Manifest.permission.RECEIVE_SMS,                    Manifest.permission.READ_SMS,                    Manifest.permission.RECEIVE_WAP_PUSH,                    Manifest.permission.RECEIVE_MMS)            STORAGE = arrayOf(                    Manifest.permission.READ_EXTERNAL_STORAGE,                    Manifest.permission.WRITE_EXTERNAL_STORAGE)        }    }    /**     * 获取单个权限的名称     */    fun getPermissionName(permission: String): String {        var permissionName = &quot;&quot;        when {            CALENDAR.contains(permission) -&gt; permissionName = &quot;日历&quot;            CAMERA.contains(permission) -&gt; permissionName = &quot;相机&quot;            CONTACTS.contains(permission) -&gt; permissionName = &quot;联系人&quot;            LOCATION.contains(permission) -&gt; permissionName = &quot;定位&quot;            MICROPHONE.contains(permission) -&gt; permissionName = &quot;麦克风&quot;            PHONE.contains(permission) -&gt; permissionName = &quot;电话&quot;            SENSORS.contains(permission) -&gt; permissionName = &quot;传感器&quot;            SMS.contains(permission) -&gt; permissionName = &quot;短信&quot;            STORAGE.contains(permission) -&gt; permissionName = &quot;读写存储&quot;        }        return permissionName    }    /**     * 获取权限的拼接名称     */    fun getPermissionName(permission: Array&lt;String&gt;): String {        val sb = StringBuilder()        permission.forEach {            val permissionName = getPermissionName(it)            if (!TextUtils.isEmpty(permissionName) &amp;&amp; !sb.contains(permissionName)) {                sb.append(&quot;$permissionName、&quot;)            }        }        sb.deleteCharAt(sb.length - 1)        return sb.toString()    }}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>width-length-ems</title>
      <link href="/2018/05/02/width-length-ems/"/>
      <url>/2018/05/02/width-length-ems/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在DemoGo中自定义公共页面头部CommTopBar时，最开始没有限制title的长度、行数,导致在title过长时，会占满整个CommTopBar。而在TextView的文本限制中官方有3种方式，maxWidth、maxEms、maxLength。</p><h3 id="maxWidth"><a href="#maxWidth" class="headerlink" title="maxWidth"></a>maxWidth</h3><p>maxWidth，传入值为dimens，TextView layout_width必须为”wrap_content”,否则该属性失效。当TextView设置maxWidth属性之后，TextView的最大宽度固定，当TextView中文字长度大于TextView的宽度时，会换行。当打到maxLines之后,ellipsize会生效。</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxLines=&quot;2&quot;        android:maxWidth=&quot;100dp&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text1.png" alt=""></p><h3 id="maxLength"><a href="#maxLength" class="headerlink" title="maxLength"></a>maxLength</h3><p>maxLength,传入值为整形，TextView layout_width可以随意赋值。设置该属性之后TextView只会展示限制长度之内的text。</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxLines=&quot;1&quot;        android:maxLength=&quot;10&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text3.png" alt=""></p><h3 id="maxEms"><a href="#maxEms" class="headerlink" title="maxEms"></a>maxEms</h3><p>maxEms,传入值为整形，TextView layout_width必须为wrap_content。例如设置maxEms=”10”,相当于规定TextView最大宽度为10em的长度。em为一个是长度单位，是根据文字的size来决定。（详情可以参考<a href="https://en.wikipedia.org/wiki/Em_%28typography%29" target="_blank" rel="noopener">Em (typography)</a>）</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxEms=&quot;10&quot;        android:maxLines=&quot;2&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text2.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="限制TextView宽度方法"><a href="#限制TextView宽度方法" class="headerlink" title="限制TextView宽度方法"></a>限制TextView宽度方法</h4><p>1.直接限制TextView的layout_width,缺点：当文本未超出TextView的宽度时，TextView还是会占用相应大小。<br>2.maxWidth，maxWidth结合wrap_content使用，给TextView规定了最大宽度，未超过时TextView根据文本计算长度，超过时TextView宽度固定为最大宽度。<br>3.maxEms，maxEms和maxWidth相同，也是给TextView规定了最大宽度，和maxWidth的区别在于最大宽度的单位是em，而em的长度取决于字体大小。<br>4.maxLength，maxLength并不是处理TextView，而是处理设置的text，设置该属性，TextView只会展示限定范围内的text。</p><h4 id="ellipsize是否生效"><a href="#ellipsize是否生效" class="headerlink" title="ellipsize是否生效"></a>ellipsize是否生效</h4><p>1.TextView layout_width设置为固定宽度，无论是否设置maxWidth、maxEms或者maxLength，只要text文本超过了TextView的宽度和最大行数，ellipsize就会生效。<br>2.TextView layout_width设置为wrap_content，maxWidth、maxEms会使ellipsize生效，maxLength会使ellipsize失效。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit+Kotlin协程封装</title>
      <link href="/2018/04/26/retrofit-coroutines/"/>
      <url>/2018/04/26/retrofit-coroutines/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇博客<a href="http://moodstrikerdd.com/2018/04/26/kotlin-coroutines/" target="_blank" rel="noopener">Kotlin协程Api用例详解</a>中了解了Kotlin协程Api的使用。目前火热的Retrofit网络请求框架也支持了Kotlin协程，本篇博客中就</p><pre><code>//集成准备    //Kotlin协程    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:0.22.5&quot;    //okhttp log拦截器    implementation &#39;com.squareup.okhttp3:logging-interceptor:3.10.0&#39;    //Retrofit2    implementation &#39;com.squareup.retrofit2:retrofit:2.4.0&#39;    //Retrofit2 gson转换器    implementation &#39;com.squareup.retrofit2:converter-gson:2.4.0&#39;    //Retrofit2 协程适配器    implementation &#39;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-experimental-adapter:1.0.0&#39;</code></pre><h3 id="Retrofit2单例"><a href="#Retrofit2单例" class="headerlink" title="Retrofit2单例"></a>Retrofit2单例</h3><p>在Retrofit是用中，推荐使用单例封装，Kotlin中使用单例也非常方便，object为单例class，参数单例可用委托by lazy</p><pre><code>/** * @author moodstrikerdd * @date 2018/4/19 * @label 单例Retrofit Retrofit帮助类 */object RetrofitHelper {    private const val BASE_URL = &quot;http://www.wanandroid.com&quot;    private const val CONNECT_TIMEOUT = 30L    private const val READ_TIMEOUT = 10L    private const val TAG = &quot;Retrofit:&quot;    private const val DATA_FRONT = &quot;Data:&quot;    //实例化api    val api: ApiService by lazy {        getService(ApiService::class.java)    }    //实例化Gson，用于控制台格式化输出json    private val gson: Gson by lazy {        GsonBuilder().setPrettyPrinting().create()    }    //实例化Retrofit    private val mRetrofit: Retrofit by lazy {        Retrofit.Builder().apply {            baseUrl(BASE_URL)            client(OkHttpClient().newBuilder().apply {                connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS)                readTimeout(READ_TIMEOUT, TimeUnit.SECONDS)                addInterceptor {                    val request = it.request()                    val newBuilder = request.newBuilder()                    //请求预处理，此处没做处理                    it.proceed(newBuilder.build())                }                //log拦截器一定要最后添加，否则后面添加的拦截器修改的内容不会打印                addInterceptor(HttpLoggingInterceptor(HttpLoggingInterceptor.Logger {                    loge(TAG, if (it.startsWith(&quot;{&quot;)) {                        //控制台格式化输出json                        val fromJson = gson.fromJson(it, Any::class.java)                        DATA_FRONT + gson.toJson(fromJson)                    } else {                        DATA_FRONT + it                    })                }))            }.build())                    //添加gson转换器                    .addConverterFactory(GsonConverterFactory.create())                    //添加Kotlin 协程适配器                    .addCallAdapterFactory(CoroutineCallAdapterFactory())        }.build()    }    private fun &lt;T&gt; getService(service: Class&lt;T&gt;): T {        return mRetrofit.create(service)    }    fun &lt;T&gt; handleResult(baseBean: BaseBean&lt;T&gt;, callback: CallBack&lt;T&gt;) {        //以http://www.wanandroid.com api例子，BaseBean根据自己实际情况定义，处理逻辑也        if (baseBean.errorCode != 0 || baseBean.data == null) {            //自定义异常            throw ServiceException(baseBean.errorCode, baseBean.errorMsg)        } else {            callback.onSuccess(baseBean.data)        }    }}</code></pre><p>ApiService在Retrofit使用中，需要定义ApiService接口。使用Kotlin协程时，返回值从Call变成了Deferred<t>。上篇博文中有讲到async/Deferred和launch/Job的区别就是acync/Deferred的挂起lambda函数会返回中Deferred<t>.await()会返回T的一个实例，而launch/Job中Job.join()没有返回值。所以Deferred<t>更适合开发中需要返回值的接口请求。</t></t></t></p><pre><code>/** * @author moodstrikerdd * @date 2018/4/19 * @label Retrofit Api */interface ApiService {    /**     * http://www.wanandroid.com     */    @GET(&quot;/friend/json&quot;)    fun getList(): Deferred&lt;BaseBean&lt;List&lt;HotWebBean&gt;&gt;&gt;}</code></pre><h3 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h3><pre><code> launch(UI) {            val deferred = async(CommonPool) {                RetrofitHelper.api.getList()            }            val await = deferred.await()            //处理数据        }</code></pre><p>看上去十分简洁，运行可以得到数据，但是在测试几次之后，发现当接口请求错误，或者内容不对使我们抛出自定异常之后，程序直接崩溃了。查看logcat可以看到当抛出异常的时候，我们这段请求逻辑并没有去try catch导致程序直接崩溃。所以还需要在请求逻辑上面添加try catch处理。</p><pre><code>  launch(UI) {           try {               val deferred = async(CommonPool) {                   RetrofitHelper.api.getList()               }               val await = deferred.await()               //处理数据           }catch (e:Exception){               e.printStackTrace()               //处理异常           }        }</code></pre><p><strong>这里抛出一个疑问，当我的try catch模块直接包含最外层的launch(UI)的时候，是不能捕获到异常的。具体我也没弄清楚原因是什么，只能推测可能是因为不能跨进程捕获异常</strong></p><h3 id="逻辑封装"><a href="#逻辑封装" class="headerlink" title="逻辑封装"></a>逻辑封装</h3><p>这里请求逻辑写好了，但是没有一套统一的回调方式来处理数据和处理异常，所以还需要定义一套回调接口，同时使用Kotlin的扩展函数做进一步的封装。部分代码如下,如需要看全部逻辑代码，可以直接去我的文章顶部的Github地址查看。</p><pre><code>fun &lt;T&gt; doHttp(createApi: () -&gt; Deferred&lt;BaseBean&lt;T&gt;&gt;, callBack: CallBack&lt;T&gt;) {    launch(UI) {        try {            val deferred = createApi()            val await = deferred.await()            RetrofitHelper.handleResult(await, callBack)        } catch (t: Throwable) {            callBack.onFailed(ExceptionHandle.handleException(t))        }    }}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> util </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin协程Api用例详解</title>
      <link href="/2018/04/26/kotlin-coroutines/"/>
      <url>/2018/04/26/kotlin-coroutines/</url>
      <content type="html"><![CDATA[<h3 id="Kotlin协程简述"><a href="#Kotlin协程简述" class="headerlink" title="Kotlin协程简述"></a>Kotlin协程简述</h3><p>开发中许多任务是需要长时间运行，并且需要调用者阻塞直到这些调用完成（比如网络 IO ，文件 IO ，CPU 或者 GPU 比较集中的工作）。在完成这些任务时我们也可以使用异步处理的方式，例如Rxjava。而协程提供了一种避免线程阻塞并且用一种更轻量级，更易操控到操作：协程暂停。</p><pre><code>//添加Kotlin协程依赖implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:0.22.5&quot;</code></pre><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>当一个函数被 suspend 修饰时表示可以被挂起，调用它会导致挂起协程，挂起函数可以和正常函数那样接受参数返回结果，但只能在协程中调用或着被其他挂起函数调用。</p><pre><code>suspend fun doSomething(){        //do something        delay(1000)    }</code></pre><p>因为delay为Kotlin封装的挂起函数，所以调用delay的函数也必须是挂起函数。</p><h3 id="协程Api"><a href="#协程Api" class="headerlink" title="协程Api"></a>协程Api</h3><p>在已有的Api中，Kotlin提供了两种方式实现协程 async/Deferred和launch/Job</p><pre><code>//async/Deferredpublic actual fun &lt;T&gt; async(    context: CoroutineContext = DefaultDispatcher,    start: CoroutineStart = CoroutineStart.DEFAULT,    parent: Job? = null,   &lt;strong&gt; block: suspend CoroutineScope.() -&gt; T&lt;/strong&gt;): Deferred&lt;T&gt; {    val newContext = newCoroutineContext(context, parent)    val coroutine = if (start.isLazy)        LazyDeferredCoroutine(newContext, block) else        DeferredCoroutine&lt;T&gt;(newContext, active = true)    coroutine.start(start, coroutine, block)    return coroutine}</code></pre><pre><code>//launch/Jobpublic expect fun launch(    context: CoroutineContext = DefaultDispatcher,    start: CoroutineStart = CoroutineStart.DEFAULT,    parent: Job? = null,   &lt;strong&gt; block: suspend CoroutineScope.() -&gt; Unit&lt;/strong&gt;): Job</code></pre><p>从源码中可以看出async和launch的参数列表中只有最后一个参数：带有 suspend 修饰的函数类型不同，async中的lambda有返回值，和Deferred的类型相同。launch中的lambda没有返回值。</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>两个Api的构造函数中，第一个参数为context。在android开发中比较常用的两个为UI何CommonPool。<br>UI为主线程，UI线程，只有context是UI的launch或者async的block lambda中才能更新UI<br>CommonPool为公共的线程池，在context是CommonPool的lauch或者async中的block lambda中可以异步处理耗时操作。</p><pre><code>launch(UI) {            text.setText(&quot;UI&quot;)        }async(UI) {            text.setText(&quot;UI&quot;)        }launch(CommonPool) {            delay(1000)        }async(CommonPool) {            delay(1000)        }</code></pre><h4 id="async-Deferred"><a href="#async-Deferred" class="headerlink" title="async/Deferred"></a>async/Deferred</h4><pre><code> async{            loge(message = &quot;outer start&quot;)            val inner = async{                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)                &quot;stop&quot;            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            val await = inner.await()            loge(message = &quot;outer stop&quot;)            await        }//        依次打印//        16:30:41.759 14668-14737/com.moo.demogo E/DemoGo: outer start//        16:30:41.761 14668-14737/com.moo.demogo E/DemoGo: outer wait itself start//        16:30:41.768 14668-14737/com.moo.demogo E/DemoGo: inner start//        16:30:42.268 14668-14738/com.moo.demogo E/DemoGo: outer wait itself stop//        16:30:42.268 14668-14738/com.moo.demogo E/DemoGo: outer wait inner//        16:30:42.771 14668-14738/com.moo.demogo E/DemoGo: inner stop//        16:30:42.772 14668-14738/com.moo.demogo E/DemoGo: outer stop</code></pre><p>从打印的信息可以看出outer（外层async）开始线性调用，打印outer start，在inner创建之后inner也开始执行，（outer wait itself start打印在inner start之前是因为inner async在创建的过程中会耗费极少的时间，而在这段时间内outer已经执行到下一步，理论上在inner创建之后，inner和outer之后都是同步执行）当outer等待500ms之后 outer打印outer wait itself stop同时开始等待inner，打印outer wait inner，下面这句代码val await = inner.await()为Kotlin协程重点。正常情况下，outer会直接打印outer stop，之后等待500ms之后 inner stop。但是由于inner.await(),outer会挂起，等待inner执行结束，返回字符串“stop”之后，outer再结束，这也就是为什么最后是outer wait inner500ms之后inner stop 然后才是outer stop</p><h4 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch/Job"></a>launch/Job</h4><pre><code>launch{            loge(message = &quot;outer start&quot;)            val inner = launch{                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            inner.join()            loge(message = &quot;outer stop&quot;)        }//        依次打印//        16:57:05.431 20131-20298/com.moo.demogo E/DemoGo: outer start//        16:57:05.432 20131-20298/com.moo.demogo E/DemoGo: outer wait itself start//        16:57:05.432 20131-20300/com.moo.demogo E/DemoGo: inner start//        16:57:05.940 20131-20298/com.moo.demogo E/DemoGo: outer wait itself stop//        16:57:05.940 20131-20298/com.moo.demogo E/DemoGo: outer wait inner//        16:57:06.439 20131-20298/com.moo.demogo E/DemoGo: inner stop//        16:57:06.441 20131-20300/com.moo.demogo E/DemoGo: outer stop</code></pre><p>打印信息和async/Deferred一致，区别在与lauch返回Job，挂起方法为job.join()且没有返回值。</p><p>async和launch可以根据是否需要返回值这一特点选择使用或者混合使用</p><pre><code>launch {            loge(message = &quot;outer start&quot;)            val inner = async {                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)                &quot;stop&quot;            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            val await = inner.await()            //deal result await            loge(message = &quot;outer stop&quot;)        }</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>源码分析SwipeRefreshLayout子View侧滑冲突（侧滑菜单ListView，ViewPager）</title>
      <link href="/2018/04/25/tips-swiperefreshlayout/"/>
      <url>/2018/04/25/tips-swiperefreshlayout/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间项目需要侧滑菜单的ListView，所以自己重写ListView仿qq的部分效果自定义了一个SideslipListView，在Dome里面运行正常，但是在使用的时候，发现经常侧滑有时候滑一半就失灵了，并且同时触发了SwipeRefreshLayout的下拉刷新CircleImageView的显示。反复试验了几次并配合log，得出问题：<strong>当SideslipListView到了顶部且侧滑的时候出现垂直方向滑动，会导致子View的滑动事件失效，SwipeRefreshLayout处理了滑动事件，显示顶部CircleImageView。</strong>因为我的SideslipListView是通过对触摸事件做处理实现侧滑的，所以我第一反应就是可能滑动冲突了。</p><h3 id="Android事件分发"><a href="#Android事件分发" class="headerlink" title="Android事件分发"></a>Android事件分发</h3><p><div align="center"><img src="https://img-blog.csdn.net/20180411112342276"></div><br>上面这张图相信所有人都烂熟于心了，简单分析可以知道SwipeRefreshLayout可能搞事情的地方是<strong>dispatchTouchEvent ，onInterceptTouchEvent</strong>。那就去看看源码中是如何实现。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>SwipeRefreshLayout继承自ViewGroup，在SwipeRefreshLayout中没有重写dispatchTouchEvent，只重写了 onInterceptTouchEvent，所以只用看在onInterceptTouchEvent中怎么处理的。<br><pre><code>@Override   public boolean onInterceptTouchEvent(MotionEvent ev) {       ensureTarget();       final int action = ev.getActionMasked();       int pointerIndex;       if (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) {           mReturningToStart = false;       }       if (!isEnabled() || mReturningToStart || canChildScrollUp()               || mRefreshing || mNestedScrollInProgress) {           &#x2F;&#x2F; Fail fast if we&#39;re not in a state where a swipe is possible           return false;       }       switch (action) {           case MotionEvent.ACTION_DOWN:               setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCircleView.getTop());               mActivePointerId = ev.getPointerId(0);               mIsBeingDragged = false;               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               mInitialDownY = ev.getY(pointerIndex);               break;           case MotionEvent.ACTION_MOVE:               if (mActivePointerId == INVALID_POINTER) {                   Log.e(LOG_TAG, &quot;Got ACTION_MOVE event but don&#39;t have an active pointer id.&quot;);                   return false;               }               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               final float y = ev.getY(pointerIndex);               startDragging(y);               break;           case MotionEvent.ACTION_POINTER_UP:               onSecondaryPointerUp(ev);               break;           case MotionEvent.ACTION_UP:           case MotionEvent.ACTION_CANCEL:               mIsBeingDragged = false;               mActivePointerId = INVALID_POINTER;               break;       }       return mIsBeingDragged;   }</code></pre><br>可以看到最终返回的是mIsBeingDragged的值，mIsBeingDragged表示SwipeRefreshLayout是否开始下拉刷新的操作，即SwipeRefreshLayout顶部的CircleImageView是否开始显示。mIsBeingDragged的值是true时，就会导致SwipeRefreshLayout的子View不能接受到相应的事件。</p><p>在分Action处理事件之前有一段代码</p><pre><code>if (!isEnabled() || mReturningToStart || canChildScrollUp()                || mRefreshing || mNestedScrollInProgress) {            // Fail fast if we&#39;re not in a state where a swipe is possible            return false;        }</code></pre><p>这段代码在SwipeRefreshLayout不可用，或者SwipeRefreshLayout的子View没有滑动到了顶部(其中ListView的判断是canChildScrollUp())的时候直接返回false，不拦截子view的触摸事件。这也就是为什么最开始产生的问题中，必须是SideSlipListView滑动到顶部的时候才会产生。</p><pre><code>public boolean canChildScrollUp() {    if (mChildScrollUpCallback != null) {        return mChildScrollUpCallback.canChildScrollUp(this, mTarget);    }    if (mTarget instanceof ListView) {        return ListViewCompat.canScrollList((ListView) mTarget, -1);    }    return mTarget.canScrollVertically(-1);}</code></pre><p>ACTION_DOWN ：mIsBeingDragged的第一次赋值在ACTION_DOWN中赋值为false，ACTION_DOWN中其他的代码都是初始化一些参数，可以略过。</p><p>ACTION_MOVE:在ACTION_MOVE中获取了触摸的Y坐标，然后调用了startDrag个ing（y）,跟踪过去。</p><pre><code>private void startDragging(float y) {       final float yDiff = y - mInitialDownY;       if (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) {           mInitialMotionY = mInitialDownY + mTouchSlop;           mIsBeingDragged = true;           mProgress.setAlpha(STARTING_PROGRESS_ALPHA);       }   }</code></pre><p>这里一目了然，把当前的y坐标和ACTION_DOWN中的起始y坐标求差，当Y轴的移动距离大于系统最小滑动距离的时候，会将mIsBeingDragged从false变成true,从而使onInterceptTouchEvent返回true，拦截子View的触摸事件。所以只要我们重写SwipeRefreshLayout的onInterceptTouchEvent方法，当滑动事件可判断为水平滑动的时候直接返回false，就可以解决SwipeRefreshLayout下子View的水平滑动冲突了。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code>/** * 是否让子view处理touch事件 */private boolean letChildDealTouchEvent;private float startX;private float startY;private int mTouchSlop;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) {    switch (ev.getAction()) {        case MotionEvent.ACTION_DOWN:            // 记录手指按下的位置            startY = ev.getY();            startX = ev.getX();            // 初始化标记            letChildDealTouchEvent = false;            break;        case MotionEvent.ACTION_MOVE:            // 如果子view正在拖拽中，那么不拦截它的事件，直接return false；            if (letChildDealTouchEvent) {                return false;            }            // 获取当前手指位置            float endY = ev.getY();            float endX = ev.getX();            float distanceX = Math.abs(endX - startX);            float distanceY = Math.abs(endY - startY);            // 如果X轴位移大于Y轴位移，那么将事件交给子View处理            if (distanceX &gt; mTouchSlop &amp;&amp; distanceX &gt; distanceY) {                letChildDealTouchEvent = true;                return false;            }            break;        case MotionEvent.ACTION_UP:        case MotionEvent.ACTION_CANCEL:            // 初始化标记            letChildDealTouchEvent = false;            break;        default:            break;    }    return super.onInterceptTouchEvent(ev);}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>当SwipeRefreshLayout可用且在子view滑动到顶部的时候，会对垂直方向的滑动事件做判断，当垂直方向向下的滑动距离大于系统最小滑动距离的时候，会拦截子View的Touch事件，开始做下拉刷新处理。重写SwipeRefreshLayout的onInterceptTouchEvent事件，对水平滑动做相应处理，可以避免该问题产生。 </strong></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
