<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>代理模式以及实现onClick事件预处理优化</title>
      <link href="/2019/01/08/proxy/"/>
      <url>/2019/01/08/proxy/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在之前的工作中封装过IOC实现的onClick事件注入及其网络和重复点击的判断（<a href="https://moodstrikerdd.github.io/2018/07/31/ioc-onclick/">IoC实现点击事件判断网络、防止连续点击</a>）。在后续的工作中发现对于onClick事件的相关判断可以通过代理的方式实现，因此对相关的封装代码做了相应的改动于封装。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。<br>以本次实现的onClick事件预处理为例。<br>1.具体需要实现的接口，OnClickListener。</p><pre><code> public interface OnClickListener {        void onClick(View v); }</code></pre><p> 2.判断网络状态的代理类，代理类实现了OnClickListener，同时代理类中持有一个OnClickListener的引用。在具体的onClick实现方法中，代理类先判断是否有网络，在有网络的情况下调用被代理OnClickListener的onClick方法，否则不触发点击事件。</p><pre><code> class OnClickListenerNetProxy(private val onClickListener: View.OnClickListener?) : View.OnClickListener {     override fun onClick(v: View) {         if (AppUtils.hasNet()) {             onClickListener?.onClick(v)         }     } }</code></pre><p>3.具体使用</p><pre><code> view.setOnClickListener(OnClickListenerNetProxy(View.OnClickListener {            toast(&quot;控件被点击了&quot;)        }))</code></pre><p>同样的，也可以定义防止重复点击的代理类嵌套使用。</p><pre><code>class OnClickListenerRepeatProxy(private val onClickListener: View.OnClickListener?,                                 private val second: Long = 1000) : View.OnClickListener {    private var lastClickTimeMills = 0L    override fun onClick(v: View) {        if (System.currentTimeMillis() - lastClickTimeMills &gt;= second) {            lastClickTimeMills = System.currentTimeMillis()            onClickListener?.onClick(v)        }    }}//嵌套调用，先防止重复点击，后判断有无网络，条件通过时处理点击事件。view.setOnClickListener(OnClickListenerRepeatProxy(OnClickListenerNetProxy(View.OnClickListener {            toast(&quot;控件被点击了&quot;)        })))</code></pre><p>联动<a href="https://moodstrikerdd.github.io/2018/07/31/ioc-onclick/">IoC实现点击事件判断网络、防止连续点击</a> 中的bind方法可以优化,从而不需要将所有的预处理都放到同一个地方执行。</p><pre><code>private fun injectOnClickAop(any: Any, contentView: View?) {        val javaClass = any.javaClass        val declaredMethods = javaClass.declaredMethods        if (declaredMethods != null &amp;&amp; declaredMethods.isNotEmpty()) {            declaredMethods.forEach { method -&gt;                val onClick = method.getAnnotation(OnClick::class.java)                val checkNet = method.getAnnotation(CheckNet::class.java)                val limitRepeatClick = method.getAnnotation(LimitRepeatClick::class.java)                if (onClick != null) {                    val values = onClick.value                    values.forEach { viewId -&gt;                        val view = (if (any is Activity) {                            any.findViewById(viewId)                        } else {                            contentView?.findViewById&lt;View&gt;(viewId)                        }) ?: throw RuntimeException(&quot;OnClick注解中存在无效id&quot;)                        var onClickListener = View.OnClickListener {                            method.isAccessible = true                            method.invoke(any, it)                        }                        if (checkNet != null &amp;&amp; (checkNet.value.isEmpty() || viewId in checkNet.value)) {                            onClickListener = OnClickListenerNetProxy(onClickListener)                        }                        if (limitRepeatClick != null) {                            onClickListener = OnClickListenerRepeatProxy(onClickListener, limitRepeatClick.value)                        }                        view.setOnClickListener(onClickListener)                    }                }            }        }    }</code></pre><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>代理类在程序运行时创建的代理方式被成为动态代理。动态代理代理类的Class文件有JDK在运行时创建。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。例如Retrofit框架中就是使用动态代理实现网络请求的统一处理。</p><pre><code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></pre><p>Proxy.newProxyInstance()方法有三个参数：</p><p>1.loader 类加载器(Class Loader)</p><p>2.interfaces 需要实现的接口数组</p><p>3.h InvocationHandler接口。所有动态代理类的方法调用，都会交由InvocationHandler接口实现类里的invoke()方法去处理。这是动态代理的关键所在。</p><pre><code>public interface InvocationHandler {    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable;}</code></pre><ol><li><p>动态代理类的引用，通常情况下不需要它。但可以使用getClass()方法，得到proxy的Class类从而取得实例的类信息，如方法列表，annotation等。</p></li><li><p>方法对象的引用，代表被动态代理类调用的方法。从中可得到方法名，参数类型，返回类型等等</p></li><li><p>args对象数组，代表被调用方法的参数。注意基本类型(int,long)会被装箱成对象类型(Interger, Long)</p></li></ol><p>例如定义一个请求数据的接口,以及实现。</p><pre><code>interface NetRequest {    fun getBean(): Person    fun getList(): List&lt;Person&gt;}class NetRequestImpl : NetRequest{    override fun getBean() = Person(&quot;张三&quot;, &quot;Moo&quot;)    override fun getList() = arrayListOf(            Person(&quot;张三&quot;, &quot;Moo&quot;),            Person(&quot;李四&quot;, &quot;Noo&quot;),            Person(&quot;王五&quot;, &quot;Ooo&quot;))}</code></pre><p>如果我们需要知道各个方法执行的时间，第一个想到的方法就是在调用方法的前后加上当前时间打印，但是这样有多少次调用就需要写多少次打印当前时间的代码。或者是使用静态代理的方式在具体实现方法前后加上时间打印，但是如果接口中的方法有很多的话，也会产生许多重复的工作。这里使用动态代理就十分的方便。</p><pre><code>//创建被代理接口的实现类val netRequestProxy = NetRequestImpl() //调用Api生成代理类val newProxyInstance = Proxy.newProxyInstance(NetRequest::class.java.classLoader,                arrayOf&lt;Class&lt;*&gt;&gt;(NetRequest::class.java)        ) { //此处为InvocationHandler接口的实现            _, p1, p -&gt;            if (p1.declaringClass == Any::class.java) {                //Object的方法一般不处理                p1.invoke(this, *p)            } else {                //接口中需要被代理的方法                loge(message = &quot;${p1.name} start:${System.currentTimeMillis()}&quot;)                //使用反射调用实现类的具体实现方法(kotlin中反射的入参为可变参数，而这里的P是Object[]类型，所以需要传入*p)                val invoke = p1.invoke(netRequestProxy, *p)                loge(message = &quot;${p1.name} end:${System.currentTimeMillis()}&quot;)                //返回对应代理方法的返回值                invoke            }        } as NetRequest        val bean = newProxyInstance.getBean()        val toString = newProxyInstance.getList()</code></pre><p>打印信息：<br>    getBean start:1546940670732<br>    getBean end:1546940670732<br>    getList start:1546940670734<br>    getList end:1546940670735</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射机制</title>
      <link href="/2018/08/06/java-reflection/"/>
      <url>/2018/08/06/java-reflection/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="Java反射机制简介"><a href="#Java反射机制简介" class="headerlink" title="Java反射机制简介"></a>Java反射机制简介</h3><p>JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><h3 id="Java反射的作用"><a href="#Java反射的作用" class="headerlink" title="Java反射的作用"></a>Java反射的作用</h3><p>在运行时判断任意一个对象所属的类。</p><p>在运行时构造任意一个类的对象。</p><p>在运行时判断任意一个类所具有的成员变量和方法。</p><p>在运行时调用任意一个对象的方法</p><h3 id="Java反射Api"><a href="#Java反射Api" class="headerlink" title="Java反射Api"></a>Java反射Api</h3><p>反射的常用类和函数:Java反射机制的实现要借助于4个类：Class，Constructor，Field，Method；其中class代表的是类对象，Constructor－类的构造器对象，Field－类的属性对象，Method－类的方法对象，通过这四个对象我们可以粗略的看到一个类的各个组成部分。</p><h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes.class字节码文件中。<strong> 在运行期间，一个类，只有一个Class对象产生 </strong></p><h5 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h5><p>1 Object ——&gt; getClass();</p><pre><code>A a = new A();Class aClass = a.getClass();</code></pre><p>2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性</p><pre><code>Class aClass = A.class;</code></pre><p>3 通过Class类的静态方法：forName（String  className）(常用)</p><pre><code>try {        Class aClass = Class.forName(&quot;XXX.A&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名    } catch (ClassNotFoundException e) {        e.printStackTrace();    }</code></pre><h5 id="获得构造器的方法"><a href="#获得构造器的方法" class="headerlink" title="获得构造器的方法"></a>获得构造器的方法</h5><pre><code>Constructor getConstructor(Class[] params) -- 获得使用特殊的参数类型的公共构造函数， Constructor[] getConstructors() -- 获得类的所有公共构造函数 Constructor getDeclaredConstructor(Class[] params) -- 获得使用特定参数类型的构造函数Constructor[] getDeclaredConstructors() -- 获得类的所有构造函数</code></pre><h5 id="获得字段信息的方法"><a href="#获得字段信息的方法" class="headerlink" title="获得字段信息的方法"></a>获得字段信息的方法</h5><pre><code>Field getField(String name) -- 获得命名的公共字段 Field[] getFields() -- 获得类的所有公共字段 Field getDeclaredField(String name) -- 获得类声明的命名的字段 Field[] getDeclaredFields() -- 获得类声明的所有字段</code></pre><h5 id="获得方法信息的方法"><a href="#获得方法信息的方法" class="headerlink" title="获得方法信息的方法"></a>获得方法信息的方法</h5><pre><code>Method getMethod(String name, Class[] params) -- 使用特定的参数类型，获得命名的公共方法 Method[] getMethods() -- 获得类的所有公共方法 Method getDeclaredMethod(String name, Class[] params) -- 使用特写的参数类型，获得类声明的命名的方法 Method[] getDeclaredMethods() -- 获得类声明的所有方法</code></pre><h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><pre><code>Class&lt;T&gt; getDeclaringClass() -- 返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）Type[]    getGenericParameterTypes()    --按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。String    getName()    -- 以字符串形式返回此构造方法的名称。Class&lt;?&gt;[]    getParameterTypes()    -- 按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型T    newInstance(Object... initargs)    -- 使用此 Constructor对象表示的构造函数来创建新实例String    toGenericString()    -- 返回描述此 Constructor 的字符串，其中包括类型参数。</code></pre><h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><pre><code>void    set(Object obj, Object value)    -- 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。Object    get(Object obj)    -- 返回指定对象上此 Field 表示的字段的值Class&lt;?&gt;    getType()    -- 返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。boolean    isEnumConstant()    -- 如果此字段表示枚举类型的元素则返回 true；否则返回 falseString    toGenericString()    -- 返回一个描述此 Field（包括其一般类型）的字符串String    getName()    -- 返回此 Field 对象表示的字段的名称Class&lt;?&gt;    getDeclaringClass()    -- 返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段void    setAccessible(boolean flag)    -- 将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</code></pre><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><pre><code>Object    invoke(Object obj, Object... args)    -- 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。Class&lt;?&gt;    getReturnType()    -- 返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型Type    getGenericReturnType()    -- 返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。Class&lt;?&gt;[]    getParameterTypes()    -- 按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组Type[]    getGenericParameterTypes()    -- 按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型String    getName()    -- 以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称boolean    isVarArgs()    -- 判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。String    toGenericString()    -- 返回描述此 Method 的字符串，包括类型参数。</code></pre>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Annotation</title>
      <link href="/2018/08/06/annotation/"/>
      <url>/2018/08/06/annotation/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="Annotation定义"><a href="#Annotation定义" class="headerlink" title="Annotation定义"></a>Annotation定义</h3><p>java.lang.annotation，接口 Annotation。对于Annotation，是Java5的新特性，JDK5引入了Metadata（元数据）很容易的就能够调用Annotations。Annotations提供一些本来不属于程序的数据，比如：一段代码的作者或者告诉编译器禁止一些特殊的错误。An annotation 对代码的执行没有什么影响。Annotations使用@annotation的形式应用于代码：类(class),属性(attribute),方法(method)等等。一个Annotation出现在上面提到的开始位置，而且一般只有一行，也可以包含有任意的参数。</p><h3 id="Annotation示例"><a href="#Annotation示例" class="headerlink" title="Annotation示例"></a>Annotation示例</h3><pre><code>//java中的Annotation@Target(ElementType.TYPE)@Retention(RetentionPolicy.CLASS)public @interface MyAnnotation {}//kotlin中的Annotation@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.FUNCTION,AnnotationTarget.CLASS)annotation class OnClick(vararg val value: Int)</code></pre><h3 id="Annotation组成"><a href="#Annotation组成" class="headerlink" title="Annotation组成"></a>Annotation组成</h3><h4 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h4><p>Target用来指定Annotation的类型，表明Annotation可以用在什么地方，一个Annotation可以有多个Target的值，表示可以用在不同的地方。java中的参数为ElementType，kotlin中的参数为AnnotationTarget。</p><pre><code>//java中的Targetpublic enum ElementType {    ANNOTATION_TYPE,    //注解    CONSTRUCTOR,        //构造函数    FIELD,              //字段（包括枚举常量）    LOCAL_VARIABLE,     //局部变量    METHOD,             //方法    PACKAGE,            //包    PARAMETER,          //参数    TYPE,               //类、接口（包括注解类型）或枚举    TYPE_PARAMETER,    TYPE_USE;    private ElementType() {    }}//kotlin中的targetpublic enum class AnnotationTarget {    /** Class, interface or object, annotation class is also included */    CLASS,    /** Annotation class only */    ANNOTATION_CLASS,    /** Generic type parameter (unsupported yet) */    TYPE_PARAMETER,    /** Property */    PROPERTY,    /** Field, including property&#39;s backing field */    FIELD,    /** Local variable */    LOCAL_VARIABLE,    /** Value parameter of a function or a constructor */    VALUE_PARAMETER,    /** Constructor only (primary or secondary) */    CONSTRUCTOR,    /** Function (constructors are not included) */    FUNCTION,    /** Property getter only */    PROPERTY_GETTER,    /** Property setter only */    PROPERTY_SETTER,    /** Type usage */    TYPE,    /** Any expression */    EXPRESSION,    /** File */    FILE,    /** Type alias */    @SinceKotlin(&quot;1.1&quot;)    TYPEALIAS}</code></pre><h4 id="Retention"><a href="#Retention" class="headerlink" title="Retention"></a>Retention</h4><p>Retention中的参数表示注解保留策略，一个Annotataion只能有一个Retention。此枚举类型的常量描述保留注解的不同策略，指定保留多长的注解。</p><pre><code>//java中的Retentionpublic enum RetentionPolicy {    CLASS,//编译器将注解存储于类对应的.class文件中，但是在运行时不能通过JVM读取（默认模式）    RUNTIME,//编译器将注解存储于.class文件中，并且可由反射获取    SOURCE;//编译器处理完之后就被抛弃    private RetentionPolicy() {    }}//kotlin中的Retentionpublic enum class AnnotationRetention {    /** Annotation isn&#39;t stored in binary output (同java中的SOURCE)*/    SOURCE,    /** Annotation is stored in binary output, but invisible for reflection(同java中的CLASS) */    BINARY,    /** Annotation is stored in binary output and visible for reflection (同java中的RUNTIME，默认模式) */    RUNTIME}</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p><pre><code>//java中注解的参数@Retention(RetentionPolicy.CLASS)@Target({ElementType.TYPE, ElementType.METHOD})public @interface JavaNetCheck {    int[] id();    String message();}//kotlin中注解的参数@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.FUNCTION)annotation class CheckNet(vararg val id: Int,val message:String)</code></pre><p>使用注解时，以key = value的形式传入相应的参数。</p><pre><code> @CheckNet(R.id.btnClick1,R.id.btnClick2, message = &quot;网络连接失败！&quot;) @JavaNetCheck(id = [R.id.btnClick1,R.id.btnClick2],message = &quot;网络连接失败！&quot;) private fun onClick(view: View) {    toast(&quot;${(view as Button).text}被点击了！&quot;) }</code></pre><p>java中如果参数名为value，则可以省略“value =”，直接赋值</p><pre><code>@Retention(RetentionPolicy.CLASS)@Target({ElementType.TYPE, ElementType.METHOD})public @interface JavaNetCheck {    int[] value();    String message();}@JavaNetCheck(R.id.btnClick1,R.id.btnClick2,message = &quot;网络连接失败！&quot;)private fun onClick(view: View) {    toast(&quot;${(view as Button).text}被点击了！&quot;)}</code></pre><p>同时，注解中的属性可以设置默认值，java使用default关键字，kotlin直接在参数列表中赋值默认值，在使用的时候该参数就为非必传参数，不传该参数的时候使用默认值。</p><pre><code>@Retention(RetentionPolicy.CLASS)@Target({ElementType.TYPE, ElementType.METHOD})public @interface JavaNetCheck {    int[] id();    String message() default &quot;网络连接失败！&quot;;}@Retention(AnnotationRetention.RUNTIME)@Target(AnnotationTarget.FUNCTION)annotation class CheckNet(vararg val id: Int,val message :String = &quot;网络连接失败！&quot;)@CheckNet(R.id.btnClick1,R.id.btnClick2)@JavaNetCheck(id = [R.id.btnClick1,R.id.btnClick2])private fun onClick(view: View) {    toast(&quot;${(view as Button).text}被点击了！&quot;)}</code></pre><h3 id="Annotation与反射"><a href="#Annotation与反射" class="headerlink" title="Annotation与反射"></a>Annotation与反射</h3><p>了解了Annotation的基本内容，如果Annotation只是给编写代码的人注解标记，并不需要如此大费周章，注解的用途还是给java程序进行注解，标记。java提供了一个接口来获取注解的实例。</p><pre><code>public interface AnnotatedElement {    default boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; var1) {        return this.getAnnotation(var1) != null;    }    &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; var1);    Annotation[] getAnnotations();    default &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; var1) {        Annotation[] var2 = this.getDeclaredAnnotationsByType(var1);        if(var2.length == 0 &amp;&amp; this instanceof Class &amp;&amp; AnnotationType.getInstance(var1).isInherited()) {            Class var3 = ((Class)this).getSuperclass();            if(var3 != null) {                var2 = var3.getAnnotationsByType(var1);            }        }        return var2;    }    default &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass) {        Objects.requireNonNull(annotationClass);        // Loop over all directly-present annotations looking for a matching one           for (Annotation annotation : getDeclaredAnnotations()) {               if (annotationClass.equals(annotation.annotationType())) {                    // More robust to do a dynamic cast at runtime instead                    // of compile-time only.                    return annotationClass.cast(annotation);               }           }        return null;    }    default &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass) {        return AnnotatedElements.getDirectOrIndirectAnnotationsByType(this, annotationClass);    }    Annotation[] getDeclaredAnnotations();}</code></pre><p>AnnotatedElement常用的方法</p><p>1.isAnnotationPresent()方法可以判断该元素是否拥有指定注解类的注解，</p><p>2.getAnnotation(Class<t> var1) 则返回指定注解类的注解，</t></p><p>3.getAnnotations()则会返回所有的注解。</p><p>实现了这个接口的类有: Class,Constructor,Executable,Field,Method,Package,Parameter,AccessibleObject这些类都位于java.lang.reflect包，这意味着我们的程序需要通过反射来识别注解。</p><pre><code>val onClick = method.getAnnotation(OnClick::class.java)if (onClick != null) {     val values = onClick.value     ... ...    }</code></pre><h3 id="Kotlin-Annotation-扩展"><a href="#Kotlin-Annotation-扩展" class="headerlink" title="Kotlin Annotation 扩展"></a>Kotlin Annotation 扩展</h3><p>由于在Kotlin中的单个申明往往对应了多个Java声明，例如，一个Property对应了一个Field和Getter和Setter,为了使标注更为精确，Kotlin中还允许使用点目标。<br>点目标的语法为 @目标:注解名 例如:@get:MyAnnotation</p><pre><code>class Country{    /*对属性的getter使用注解*/    @get:MyAnnotation2(&quot;Editable&quot;)    var name : String = &quot;&quot;    /*对属性使用注解*/    @MyAnnotation2(&quot;Editable&quot;)    var pop : Int = 0    /*对属性的Setter使用注解*/    @MyAnnotation3(&quot;Editable&quot;,&quot;Can be below 0&quot;)    @set:MyAnnotation3    var coin : Int = 0    /*对生成的Field使用注解*/    /*具有setter的属性一般会自动生成backing field(后备字段)*/    @field:MyAnnotation2(&quot;&quot;)    var army : Int = 1000}</code></pre><p>在Kotlin中支持以下点目标:</p><p>property:代表kotlin中的属性，不能被Java的注解所应用</p><p>field:为属性生成的字段（包括后备字段）</p><p>get:属性的getter</p><p>set:属性的setter</p><p>receiver:扩展函数/属性的接收者</p><p>param:构造函数的参数</p><p>setparam:属性setter的参数</p><p>delegate:委托属性存储委托实例的字段</p><p>file:在文件中声明的顶层函数与类</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IoC实现点击事件判断网络、防止连续点击</title>
      <link href="/2018/07/31/ioc-onclick/"/>
      <url>/2018/07/31/ioc-onclick/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在使用Kotlin之前，在开发中为了提升效率，一直使用的ButterKnife，因为它通过注解的方式绑定控件，点击事件等等，不用每个控件去findViewById，功能非常便捷，而且可以通过安装ButterKnife插件一键生成代码。<br>但是在使用kotlin之后，ButterKnife的这一优势就不存在了，反而kotlin还不用为了给需要的控件创建对象而占用几十上百行代码。但是kotlin没有常用的onClick绑定，所以便自己用IoC封装了一个。虽然IoC使用反射是损耗性能的方法，但是个人认为就单单使用做onClick事件的绑定，并不会有很直观的影响，提高开发效率的意义更大。</p><h3 id="ioc简介"><a href="#ioc简介" class="headerlink" title="ioc简介"></a>ioc简介</h3><p>IoC—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，IoC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI）。在java中使用发射+注解的方式即可实现。</p><h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><a href="http://moodstrikerdd.github.io/2018/08/06/annotation/">Annotation</a><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><a href="http://moodstrikerdd.github.io/2018/08/06/java-reflection//">反射</a><h3 id="封装使用"><a href="#封装使用" class="headerlink" title="封装使用"></a>封装使用</h3><pre><code>//Activity的onCreate方法中绑定AnnotationUtils().injectOnClick(this) @OnClick(R.id.btnClick1, R.id.btnClick2) @CheckNet(R.id.btnClick2) @LimitRepeatClick fun onClick(view: View) {    toast(&quot;${(view as Button).text}被点击了！&quot;) }</code></pre><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><pre><code> @Retention(AnnotationRetention.RUNTIME) @Target(AnnotationTarget.FUNCTION) annotation class OnClick(vararg val value: Int) @Retention(AnnotationRetention.RUNTIME) @Target(AnnotationTarget.FUNCTION) annotation class CheckNet(vararg val value: Int) @Retention(AnnotationRetention.RUNTIME) @Target(AnnotationTarget.FUNCTION) annotation class LimitRepeatClick(val value: Long = 1000) private fun injectOnClick(any: Any, contentView: View?) {        val javaClass = any.javaClass        val declaredMethods = javaClass.declaredMethods        if (declaredMethods != null &amp;&amp; declaredMethods.isNotEmpty()) {            declaredMethods.forEach { method -&gt;                val onClick = method.getAnnotation(OnClick::class.java)                val checkNet = method.getAnnotation(CheckNet::class.java)                val limitRepeatClick = method.getAnnotation(LimitRepeatClick::class.java)                if (onClick != null) {                    val values = onClick.value                    var offsetTime = 0L                    if (limitRepeatClick != null) {                        offsetTime = limitRepeatClick.value                    }                    values.forEach { viewId -&gt;                        val view = (if (any is Activity) {                            any.findViewById(viewId)                        } else {                            contentView?.findViewById&lt;View&gt;(viewId)                        }) ?: throw RuntimeException(&quot;OnClick注解中存在无效id&quot;)                        view.setOnClickListener {                            val lastTimeMillis = offsetTimes[viewId] ?: 0L                            val currentTimeMillis = System.currentTimeMillis()                            if (offsetTime == 0L || currentTimeMillis - lastTimeMillis &gt;= offsetTime) {                                offsetTimes[viewId] = currentTimeMillis                                if (checkNet == null || checkNet.value.isEmpty() || !checkNet.value.contains(viewId) || AppUtils.hasNet()) {                                    method.isAccessible = true                                    method.invoke(any, view)                                }                            }                        }                    }                }            }        }    }</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> kotlin </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>WebView POST封装</title>
      <link href="/2018/07/20/WebView/"/>
      <url>/2018/07/20/WebView/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在最近的开发中碰到了一下运用场景，当调用第三方的银行合作接口之后，app需要跳转到第三方银行的H5页面进行操作，本以为银行的接口会返回一个url然后通过get方式将app中的参数传给第三方H5。但是接口返回的是一个url和一个密文参数，由于安全性，银行的H5需要通过用POST请求将参数带入从而展示页面，碍于以前没有接触，下意识的以为Android的WebView不能实现，查阅过一些资料之后发现Android的WebView是可以通过POST请求的方式打开相应的网页。</p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><pre><code> //GET方式请求网页 public void loadUrl(String url) //POST方式请求网页（若url不是http或者https链接，还是会调用GET请求方式） public void postUrl(String url, byte[] postData) //调用方法  val url = &quot;https://aaa...&quot;;  val param = &quot;abcd&quot;;  //根据需求是否需要将参数加密，如Base64加密  param = Base64.encode(param.toByteArray(), Base64.DEFAULT).toString(Charsets.UTF_8)  //因为在网络传输过程中有特殊符号会自动被转义，例如‘+’等需要将参数编码后传输  val paramString = &quot;key=&quot;+URLEncoder.encode(param, &quot;UTF-8&quot;)  //url 和 params都准备好之后，就可以处理请求  webView.poutUrl(url,paramString.toByteArray())</code></pre><h3 id="请求封装"><a href="#请求封装" class="headerlink" title="请求封装"></a>请求封装</h3><p>通用WebView中需要满足GET和POST两种请求方式，所以在转到WebView的activity中时需要传POST和GET的标记量，参数由于可能有多个的情况，所以WebView中需要用Map&lt;String,String&gt;接收。<br>核心代码：</p><pre><code>companion object {    fun intentStart(context: Context, url: String, title: String?) {        val intent = Intent(context, WebViewActivity::class.java)        intent.putExtra(DefineKey.URL, url)        intent.putExtra(DefineKey.TITLE, title ?: &quot;网页&quot;)        context.startActivity(intent)    }    fun intentStart(context: Context, url: String, title: String?, params: HashMap&lt;String, String&gt;) {        val intent = Intent(context, WebViewActivity::class.java)        intent.putExtra(DefineKey.USE_POST, true)        intent.putExtra(DefineKey.URL, url)        intent.putExtra(DefineKey.TITLE, title ?: &quot;网页&quot;)        intent.putExtra(DefineKey.PARAMS_MAP, params)        context.startActivity(intent)    }}if (usePost) {    val sb = StringBuilder()    params.forEach { key, value -&gt;        sb.append(&quot;$key=${URLEncoder.encode(value, &quot;UTF-8&quot;)}&quot;)    }    webView.postUrl(url, sb.toString().toByteArray())} else {    webView.loadUrl(url)}</code></pre><h3 id="使用POST的问题"><a href="#使用POST的问题" class="headerlink" title="使用POST的问题"></a>使用POST的问题</h3><p>在成功使用POST去请求加载出页面只有，发现的新的问题：在第一个页面中输入相关信息，点击跳转到了下一个网页，再点返回键的时候第一个界面会加载失败，原因肯定是返回时第一个界面重新加载了，给WebView加上缓存，会发现缓存在POST请求的时候并不会生效。解决方式：</p><p>在一开始加载的时候我们定义了一个布尔值 userPost表示当前界面是不是使用POST请求，那么在shouldOverrideUrlLoading中就可以根据这个变量使后面的url跳转到一个新的Activity去处理</p><pre><code>  if (usePost) {    WebViewActivity.intentStart(this, url, null)    return true  }  return false</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>6.0和8.0运行时权限处理</title>
      <link href="/2018/06/05/runtime-permission/"/>
      <url>/2018/06/05/runtime-permission/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Android 6.0 SDK 23的时候，google为了安全推出了运行时权限，控制app对用户手机权限的获取。在Android 8.0 SDK 26的时候，google进一步的优化了运行时权限。</p><h3 id="6-0运行时权限"><a href="#6-0运行时权限" class="headerlink" title="6.0运行时权限"></a>6.0运行时权限</h3><h4 id="运行时权限简介"><a href="#运行时权限简介" class="headerlink" title="运行时权限简介"></a>运行时权限简介</h4><p>在6.0以前，即targetSdkVersion &lt; 23时，app获取用户手机权限，只需要在AndroidManifest.xml文件中声明相应权限即可，如：</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</code></pre><p>而在6.0以后，想要获取某些敏感权限不仅仅需要在AndroidManifest.xml文件中声明，还要通过运行时权限Api去动态获取，用户可以根据具体使用情况授权相应权限或者拒绝相应授权。</p><h4 id="敏感权限"><a href="#敏感权限" class="headerlink" title="敏感权限"></a>敏感权限</h4><p>google官方文档上有相应表格显示哪些是敏感权限，即需要兼容运行时权限的权限和权限组。<br><img src="/2018/06/05/runtime-permission/permissions.png" alt=""></p><h4 id="运行时权限Api"><a href="#运行时权限Api" class="headerlink" title="运行时权限Api"></a>运行时权限Api</h4><p>关于运行时权限，在support包中的ActivityCompat中提供了相应的Api</p><pre><code>public static int checkSelfPermission(@NonNull Context context, @NonNull String permission)public static void requestPermissions(final @NonNull Activity activity,            final @NonNull String[] permissions, final @IntRange(from = 0) int requestCode)public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,            @NonNull int[] grantResults)public static boolean shouldShowRequestPermissionRationale(@NonNull Activity activity,            @NonNull String permission)</code></pre><p><strong>checkSelfPermission</strong>：检查app是否已经被授权了某个权限，一般在请求权限之前调用。</p><p>   android.content.pm.PackageManager#PERMISSION_GRANTED 已经授权 </p><p>   android.content.pm.PackageManager#PERMISSION_DENIED 没有授权<br><strong>requestPermission</strong>：请求权限，可同时请求多个。当用户已经拒绝过该权限切选择了不再提醒 requestPermission将不会获取权限<br><strong>onRequestPermissionsResult</strong>：Activity中请求权限的结果回调<br><strong>shouldShowRequestPermissionRationale</strong>字面意思是是否应该显示请求权限的根据，在使用中有以下情况</p><p>   1.没有请求该权限之前，返回false</p><p>   2.请求拒绝该权限，但是没有选择不再提醒，返回true</p><p>   3.请求拒绝该权限，选择不再提醒，返回false（不再提醒选项一般第二次请求的时候出现）</p><h4 id="运行时权限封装"><a href="#运行时权限封装" class="headerlink" title="运行时权限封装"></a>运行时权限封装</h4><pre><code>/** * @author moodstrikerdd * @date 2018/5/31 * @label 运行时权限帮助类 */object RuntimePermissionHelper {    val permissions = arrayListOf&lt;String&gt;()    private val permissionNotAllowed = arrayListOf&lt;String&gt;()    private const val REQUEST_CODE_PERMISSION = 1001    private var requestCode = 0    /**     * 检查相应权限是否已经获取，没获取的权限放入permissionNotAllowed List中     */    fun checkPermissions(activity: Activity): Boolean {        if (Build.VERSION.SDK_INT &lt; 23) {            return true        }        permissionNotAllowed.clear()        permissions.forEach {            if (ActivityCompat.checkSelfPermission(activity, it) != PackageManager.PERMISSION_GRANTED) {                permissionNotAllowed.add(it)            }        }        return permissionNotAllowed.isEmpty()    }    /**     * 方式一 请求权限     * 先判断shouldShowRequestPermissionRationale，根据返回值决定是跳转设置界面还是请求权限     */    fun requestPermissions(activity: Activity, requestCode: Int = REQUEST_CODE_PERMISSION) {        if (Build.VERSION.SDK_INT &lt; 23) {            return        }        for (i in 0 until permissionNotAllowed.size) {            val shouldShow = ActivityCompat.shouldShowRequestPermissionRationale(activity, permissionNotAllowed[i])            val requested = SPUtils.get(permissionNotAllowed[i], false) as Boolean            if (requested &amp;&amp; !shouldShow) {                AlertDialog.Builder(activity)                        .setTitle(&quot;提示&quot;)                        .setMessage(&quot;当前应用缺少权限:${Permission.getPermissionName(permissionNotAllowed.toTypedArray())}。请点击\&quot;设置\&quot;,\&quot;权限\&quot;打开相应权限&quot;)                        .setPositiveButton(&quot;设置&quot;) { _, _ -&gt; AppUtils.getAppDetailSettingIntent(activity) }                        .setNegativeButton(&quot;取消&quot;) { dialog, _ -&gt; dialog.dismiss() }                        .create()                        .show()                return            }        }        RuntimePermissionHelper.requestCode = requestCode        permissionNotAllowed.forEach { SPUtils.put(it, true) }        ActivityCompat.requestPermissions(activity, permissionNotAllowed.toTypedArray(), requestCode)    }    /**     * 方式二 请求权限     * 直接请求未授权的权限     */    fun requestPermissions2(activity: Activity, requestCode: Int = REQUEST_CODE_PERMISSION) {        if (Build.VERSION.SDK_INT &lt; 23) {            return        }        RuntimePermissionHelper.requestCode = requestCode        permissionNotAllowed.forEach { SPUtils.put(it, true) }        ActivityCompat.requestPermissions(activity, permissionNotAllowed.toTypedArray(), requestCode)    }    /**     * 方式二 直接请求所有权限     */    fun requestPermissionsWithoutCheck(activity: Activity, requestCode: Int = REQUEST_CODE_PERMISSION) {        if (Build.VERSION.SDK_INT &lt; 23) {            return        }        RuntimePermissionHelper.requestCode = requestCode        ActivityCompat.requestPermissions(activity, permissions.toTypedArray(), requestCode)    }    /**     * 方式一 结果回调 只存在 获取权限失败和成功     */    fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray, success: (requestCode: Int) -&gt; Unit) {        if (requestCode == RuntimePermissionHelper.requestCode) {            for (i in 0 until permissions.size) {                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {                    toast(message = &quot;必须同意所有该类权限才能使用本程序&quot;)                    return                }            }            success(requestCode)        }    }    /**     * 方式二 结果回调     * 在回调结果中判断 shouldShowRequestPermissionRationale     * 三种结果     * 1.提示获取权限失败     * 2.跳转设置界面     * 3.获取权限成功     */    fun onRequestPermissionsResult2(activity: Activity, requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray, success: (requestCode: Int) -&gt; Unit) {        if (requestCode == RuntimePermissionHelper.requestCode) {            val permissionsNotAllowed = permissions.filterIndexed { index, _ -&gt;                grantResults[index] != PackageManager.PERMISSION_GRANTED            }            for (i in 0 until permissions.size) {                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {                    if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permissions[i])) {                        toast(message = &quot;必须同意${Permission.getPermissionName(permissionsNotAllowed.toTypedArray())}权限才能使                    } else {                        AlertDialog.Builder(activity)                                .setTitle(&quot;提示&quot;)                                .setMessage(&quot;当前应用缺少权限:${Permission.getPermissionName(permissionsNotAllowed.toTypedArray())}。请点击\&quot;设置\&quot;,\&quot;权限\&quot;打开相应权限&quot;)                                .setPositiveButton(&quot;设置&quot;) { _, _ -&gt; AppUtils.getAppDetailSettingIntent(activity) }                                .setNegativeButton(&quot;取消&quot;) { dialog, _ -&gt; dialog.dismiss() }                                .create()                                .show()                    }                    return                }            }            success(requestCode)        }    }}</code></pre><p>区别在于shouldShowRequestPermissionRationale的调用位置<br>1.在请求权限之前调用，当shouldShowRequestPermissionRationale返回false的时候跳转设置界面，返回true的时候调用requestPermissions请求权限<br>shouldShowRequestPermissionRationale返回false跳转设置界面是因为此时requestPermission已经不能获取权限，但是返回false的时候会有一个特殊情况就是当还未请求权限时，<br>因此需要通过SharedPreferences记录是否已经请求过该权限。在还未请求过时，请求权限，已经请求过的同时shouldShowRequestPermissionRationale发挥false的时候跳转到设置界面</p><pre><code>for (i in 0 until permissionNotAllowed.size) {            val shouldShow = ActivityCompat.shouldShowRequestPermissionRationale(activity, permissionNotAllowed[i])            val requested = SPUtils.get(permissionNotAllowed[i], false) as Boolean            if (requested &amp;&amp; !shouldShow) {                //TODO 跳转设置界面                return            }        }        RuntimePermissionHelper.requestCode = requestCode        //可请求权限，并让请求的权限标记为已请求        permissionNotAllowed.forEach { SPUtils.put(it, true) }        ActivityCompat.requestPermissions(activity, permissionNotAllowed.toTypedArray(), requestCode)</code></pre><p>2.在返回结果中调用，这种方式是为了避免还未请求时shouldShowRequestPermissionRationale返回false的特殊情况。<br>在请求权限失败的时候判断shouldShowRequestPermissionRationale的返回值，返回true的时候提示获取权限失败，false的时候跳转到设置界面。</p><pre><code>fun onRequestPermissionsResult2(activity: Activity, requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray, success: (requestCode: Int) -&gt; Unit) {        if (requestCode == RuntimePermissionHelper.requestCode) {            val permissionsNotAllowed = permissions.filterIndexed { index, _ -&gt;                grantResults[index] != PackageManager.PERMISSION_GRANTED            }            for (i in 0 until permissions.size) {                if (grantResults[i] != PackageManager.PERMISSION_GRANTED) {                    if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permissions[i])) {                        toast(message = &quot;必须同意${Permission.getPermissionName(permissionsNotAllowed.toTypedArray())}权限才能使                    } else {                       //TODO 跳转设置界面                    }                    return                }            }            success(requestCode)        }    }</code></pre><h3 id="8-0运行时权限"><a href="#8-0运行时权限" class="headerlink" title="8.0运行时权限"></a>8.0运行时权限</h3><p>在6.0到8.0之间的版本中，在运行时权限申请时，授权了组中的一个权限，会同时授权权限组中其他所有权限。而在8.0及以上版本中授权组中的一个权限，并不同时授权组中其他的权限，但是当你再次请求组中其他权限的时候，会直接授权，不需要用户选择。<br>例如 Manifest.permission.READ_EXTERNAL_STORAGE和Manifest.permission.WRITE_EXTERNAL_STORAGE，在6.0~8.0之间只需请求其中一个，另一个就会同时授权，而在8.0以上，授权了其中一个，当需要另一个权限的时候需要再次手动调用requestPermission，否则不会获的授权。<br>适配方式：<br>        1.请求权限时，将同组的权限全部请求授权。<br>        2.在每个需要权限的地方，都去申请相关权限。</p><pre><code>/** * @author moodstrikerdd * @date 2018/5/31 * @label 6.0运行时权限 */object Permission {    /**     *读写日历。     */    val CALENDAR: Array&lt;String&gt;    /**     * 相机。     */    val CAMERA: Array&lt;String&gt;    /**     * 读写联系人。     */    val CONTACTS: Array&lt;String&gt;    /**     * 读位置信息。     */    val LOCATION: Array&lt;String&gt;    /**     * 使用麦克风。     */    val MICROPHONE: Array&lt;String&gt;    /**     * 读电话状态、打电话、读写电话记录。     */    val PHONE: Array&lt;String&gt;    /**     * 传感器。     */    val SENSORS: Array&lt;String&gt;    /**     * 读写短信、收发短信。     */    val SMS: Array&lt;String&gt;    /**     * 读写存储卡。     */    val STORAGE: Array&lt;String&gt;    init {        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) {            CALENDAR = arrayOf()            CAMERA = arrayOf()            CONTACTS = arrayOf()            LOCATION = arrayOf()            MICROPHONE = arrayOf()            PHONE = arrayOf()            SENSORS = arrayOf()            SMS = arrayOf()            STORAGE = arrayOf()        } else {            CALENDAR = arrayOf(                    Manifest.permission.READ_CALENDAR,                    Manifest.permission.WRITE_CALENDAR)            CAMERA = arrayOf(                    Manifest.permission.CAMERA)            CONTACTS = arrayOf(                    Manifest.permission.READ_CONTACTS,                    Manifest.permission.WRITE_CONTACTS,                    Manifest.permission.GET_ACCOUNTS)            LOCATION = arrayOf(                    Manifest.permission.ACCESS_FINE_LOCATION,                    Manifest.permission.ACCESS_COARSE_LOCATION)            MICROPHONE = arrayOf(                    Manifest.permission.RECORD_AUDIO)            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {                PHONE = arrayOf(                        Manifest.permission.READ_PHONE_STATE,                        Manifest.permission.READ_PHONE_NUMBERS,                        Manifest.permission.ANSWER_PHONE_CALLS,                        Manifest.permission.ADD_VOICEMAIL,                        Manifest.permission.CALL_PHONE,                        Manifest.permission.READ_CALL_LOG,                        Manifest.permission.WRITE_CALL_LOG,                        Manifest.permission.USE_SIP,                        Manifest.permission.PROCESS_OUTGOING_CALLS)            } else {                PHONE = arrayOf(                        Manifest.permission.READ_PHONE_STATE,                        Manifest.permission.ADD_VOICEMAIL,                        Manifest.permission.CALL_PHONE,                        Manifest.permission.READ_CALL_LOG,                        Manifest.permission.WRITE_CALL_LOG,                        Manifest.permission.USE_SIP,                        Manifest.permission.PROCESS_OUTGOING_CALLS)            }            SENSORS = arrayOf(                    Manifest.permission.BODY_SENSORS)            SMS = arrayOf(                    Manifest.permission.SEND_SMS,                    Manifest.permission.RECEIVE_SMS,                    Manifest.permission.READ_SMS,                    Manifest.permission.RECEIVE_WAP_PUSH,                    Manifest.permission.RECEIVE_MMS)            STORAGE = arrayOf(                    Manifest.permission.READ_EXTERNAL_STORAGE,                    Manifest.permission.WRITE_EXTERNAL_STORAGE)        }    }    /**     * 获取单个权限的名称     */    fun getPermissionName(permission: String): String {        var permissionName = &quot;&quot;        when {            CALENDAR.contains(permission) -&gt; permissionName = &quot;日历&quot;            CAMERA.contains(permission) -&gt; permissionName = &quot;相机&quot;            CONTACTS.contains(permission) -&gt; permissionName = &quot;联系人&quot;            LOCATION.contains(permission) -&gt; permissionName = &quot;定位&quot;            MICROPHONE.contains(permission) -&gt; permissionName = &quot;麦克风&quot;            PHONE.contains(permission) -&gt; permissionName = &quot;电话&quot;            SENSORS.contains(permission) -&gt; permissionName = &quot;传感器&quot;            SMS.contains(permission) -&gt; permissionName = &quot;短信&quot;            STORAGE.contains(permission) -&gt; permissionName = &quot;读写存储&quot;        }        return permissionName    }    /**     * 获取权限的拼接名称     */    fun getPermissionName(permission: Array&lt;String&gt;): String {        val sb = StringBuilder()        permission.forEach {            val permissionName = getPermissionName(it)            if (!TextUtils.isEmpty(permissionName) &amp;&amp; !sb.contains(permissionName)) {                sb.append(&quot;$permissionName、&quot;)            }        }        sb.deleteCharAt(sb.length - 1)        return sb.toString()    }}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>width-length-ems</title>
      <link href="/2018/05/02/width-length-ems/"/>
      <url>/2018/05/02/width-length-ems/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在DemoGo中自定义公共页面头部CommTopBar时，最开始没有限制title的长度、行数,导致在title过长时，会占满整个CommTopBar。而在TextView的文本限制中官方有3种方式，maxWidth、maxEms、maxLength。</p><h3 id="maxWidth"><a href="#maxWidth" class="headerlink" title="maxWidth"></a>maxWidth</h3><p>maxWidth，传入值为dimens，TextView layout_width必须为”wrap_content”,否则该属性失效。当TextView设置maxWidth属性之后，TextView的最大宽度固定，当TextView中文字长度大于TextView的宽度时，会换行。当打到maxLines之后,ellipsize会生效。</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView1&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxLines=&quot;2&quot;        android:maxWidth=&quot;100dp&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text1.png" alt=""></p><h3 id="maxLength"><a href="#maxLength" class="headerlink" title="maxLength"></a>maxLength</h3><p>maxLength,传入值为整形，TextView layout_width可以随意赋值。设置该属性之后TextView只会展示限制长度之内的text。</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView3&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxLines=&quot;1&quot;        android:maxLength=&quot;10&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text3.png" alt=""></p><h3 id="maxEms"><a href="#maxEms" class="headerlink" title="maxEms"></a>maxEms</h3><p>maxEms,传入值为整形，TextView layout_width必须为wrap_content。例如设置maxEms=”10”,相当于规定TextView最大宽度为10em的长度。em为一个是长度单位，是根据文字的size来决定。（详情可以参考<a href="https://en.wikipedia.org/wiki/Em_%28typography%29" target="_blank" rel="noopener">Em (typography)</a>）</p><pre><code> &lt;TextView        android:id=&quot;@+id/textView2&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_margin=&quot;50dp&quot;        android:ellipsize=&quot;end&quot;        android:maxEms=&quot;10&quot;        android:maxLines=&quot;2&quot;        android:text=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot; /&gt;</code></pre><p><img src="/2018/05/02/width-length-ems/text2.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="限制TextView宽度方法"><a href="#限制TextView宽度方法" class="headerlink" title="限制TextView宽度方法"></a>限制TextView宽度方法</h4><p>1.直接限制TextView的layout_width,缺点：当文本未超出TextView的宽度时，TextView还是会占用相应大小。<br>2.maxWidth，maxWidth结合wrap_content使用，给TextView规定了最大宽度，未超过时TextView根据文本计算长度，超过时TextView宽度固定为最大宽度。<br>3.maxEms，maxEms和maxWidth相同，也是给TextView规定了最大宽度，和maxWidth的区别在于最大宽度的单位是em，而em的长度取决于字体大小。<br>4.maxLength，maxLength并不是处理TextView，而是处理设置的text，设置该属性，TextView只会展示限定范围内的text。</p><h4 id="ellipsize是否生效"><a href="#ellipsize是否生效" class="headerlink" title="ellipsize是否生效"></a>ellipsize是否生效</h4><p>1.TextView layout_width设置为固定宽度，无论是否设置maxWidth、maxEms或者maxLength，只要text文本超过了TextView的宽度和最大行数，ellipsize就会生效。<br>2.TextView layout_width设置为wrap_content，maxWidth、maxEms会使ellipsize生效，maxLength会使ellipsize失效。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Retrofit+Kotlin协程封装</title>
      <link href="/2018/04/26/retrofit-coroutines/"/>
      <url>/2018/04/26/retrofit-coroutines/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一篇博客<a href="http://moodstrikerdd.com/2018/04/26/kotlin-coroutines/" target="_blank" rel="noopener">Kotlin协程Api用例详解</a>中了解了Kotlin协程Api的使用。目前火热的Retrofit网络请求框架也支持了Kotlin协程，本篇博客中就</p><pre><code>//集成准备    //Kotlin协程    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:0.22.5&quot;    //okhttp log拦截器    implementation &#39;com.squareup.okhttp3:logging-interceptor:3.10.0&#39;    //Retrofit2    implementation &#39;com.squareup.retrofit2:retrofit:2.4.0&#39;    //Retrofit2 gson转换器    implementation &#39;com.squareup.retrofit2:converter-gson:2.4.0&#39;    //Retrofit2 协程适配器    implementation &#39;com.jakewharton.retrofit:retrofit2-kotlin-coroutines-experimental-adapter:1.0.0&#39;</code></pre><h3 id="Retrofit2单例"><a href="#Retrofit2单例" class="headerlink" title="Retrofit2单例"></a>Retrofit2单例</h3><p>在Retrofit是用中，推荐使用单例封装，Kotlin中使用单例也非常方便，object为单例class，参数单例可用委托by lazy</p><pre><code>/** * @author moodstrikerdd * @date 2018/4/19 * @label 单例Retrofit Retrofit帮助类 */object RetrofitHelper {    private const val BASE_URL = &quot;http://www.wanandroid.com&quot;    private const val CONNECT_TIMEOUT = 30L    private const val READ_TIMEOUT = 10L    private const val TAG = &quot;Retrofit:&quot;    private const val DATA_FRONT = &quot;Data:&quot;    //实例化api    val api: ApiService by lazy {        getService(ApiService::class.java)    }    //实例化Gson，用于控制台格式化输出json    private val gson: Gson by lazy {        GsonBuilder().setPrettyPrinting().create()    }    //实例化Retrofit    private val mRetrofit: Retrofit by lazy {        Retrofit.Builder().apply {            baseUrl(BASE_URL)            client(OkHttpClient().newBuilder().apply {                connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS)                readTimeout(READ_TIMEOUT, TimeUnit.SECONDS)                addInterceptor {                    val request = it.request()                    val newBuilder = request.newBuilder()                    //请求预处理，此处没做处理                    it.proceed(newBuilder.build())                }                //log拦截器一定要最后添加，否则后面添加的拦截器修改的内容不会打印                addInterceptor(HttpLoggingInterceptor(HttpLoggingInterceptor.Logger {                    loge(TAG, if (it.startsWith(&quot;{&quot;)) {                        //控制台格式化输出json                        val fromJson = gson.fromJson(it, Any::class.java)                        DATA_FRONT + gson.toJson(fromJson)                    } else {                        DATA_FRONT + it                    })                }))            }.build())                    //添加gson转换器                    .addConverterFactory(GsonConverterFactory.create())                    //添加Kotlin 协程适配器                    .addCallAdapterFactory(CoroutineCallAdapterFactory())        }.build()    }    private fun &lt;T&gt; getService(service: Class&lt;T&gt;): T {        return mRetrofit.create(service)    }    fun &lt;T&gt; handleResult(baseBean: BaseBean&lt;T&gt;, callback: CallBack&lt;T&gt;) {        //以http://www.wanandroid.com api例子，BaseBean根据自己实际情况定义，处理逻辑也        if (baseBean.errorCode != 0 || baseBean.data == null) {            //自定义异常            throw ServiceException(baseBean.errorCode, baseBean.errorMsg)        } else {            callback.onSuccess(baseBean.data)        }    }}</code></pre><p>ApiService在Retrofit使用中，需要定义ApiService接口。使用Kotlin协程时，返回值从Call变成了Deferred<t>。上篇博文中有讲到async/Deferred和launch/Job的区别就是acync/Deferred的挂起lambda函数会返回中Deferred<t>.await()会返回T的一个实例，而launch/Job中Job.join()没有返回值。所以Deferred<t>更适合开发中需要返回值的接口请求。</t></t></t></p><pre><code>/** * @author moodstrikerdd * @date 2018/4/19 * @label Retrofit Api */interface ApiService {    /**     * http://www.wanandroid.com     */    @GET(&quot;/friend/json&quot;)    fun getList(): Deferred&lt;BaseBean&lt;List&lt;HotWebBean&gt;&gt;&gt;}</code></pre><h3 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h3><pre><code> launch(UI) {            val deferred = async(CommonPool) {                RetrofitHelper.api.getList()            }            val await = deferred.await()            //处理数据        }</code></pre><p>看上去十分简洁，运行可以得到数据，但是在测试几次之后，发现当接口请求错误，或者内容不对使我们抛出自定异常之后，程序直接崩溃了。查看logcat可以看到当抛出异常的时候，我们这段请求逻辑并没有去try catch导致程序直接崩溃。所以还需要在请求逻辑上面添加try catch处理。</p><pre><code>  launch(UI) {           try {               val deferred = async(CommonPool) {                   RetrofitHelper.api.getList()               }               val await = deferred.await()               //处理数据           }catch (e:Exception){               e.printStackTrace()               //处理异常           }        }</code></pre><p><strong>这里抛出一个疑问，当我的try catch模块直接包含最外层的launch(UI)的时候，是不能捕获到异常的。具体我也没弄清楚原因是什么，只能推测可能是因为不能跨进程捕获异常</strong></p><h3 id="逻辑封装"><a href="#逻辑封装" class="headerlink" title="逻辑封装"></a>逻辑封装</h3><p>这里请求逻辑写好了，但是没有一套统一的回调方式来处理数据和处理异常，所以还需要定义一套回调接口，同时使用Kotlin的扩展函数做进一步的封装。部分代码如下,如需要看全部逻辑代码，可以直接去我的文章顶部的Github地址查看。</p><pre><code>fun &lt;T&gt; doHttp(createApi: () -&gt; Deferred&lt;BaseBean&lt;T&gt;&gt;, callBack: CallBack&lt;T&gt;) {    launch(UI) {        try {            val deferred = createApi()            val await = deferred.await()            RetrofitHelper.handleResult(await, callBack)        } catch (t: Throwable) {            callBack.onFailed(ExceptionHandle.handleException(t))        }    }}</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> util </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin协程Api用例详解</title>
      <link href="/2018/04/26/kotlin-coroutines/"/>
      <url>/2018/04/26/kotlin-coroutines/</url>
      <content type="html"><![CDATA[<h3 id="Kotlin协程简述"><a href="#Kotlin协程简述" class="headerlink" title="Kotlin协程简述"></a>Kotlin协程简述</h3><p>开发中许多任务是需要长时间运行，并且需要调用者阻塞直到这些调用完成（比如网络 IO ，文件 IO ，CPU 或者 GPU 比较集中的工作）。在完成这些任务时我们也可以使用异步处理的方式，例如Rxjava。而协程提供了一种避免线程阻塞并且用一种更轻量级，更易操控到操作：协程暂停。</p><pre><code>//添加Kotlin协程依赖implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:0.22.5&quot;</code></pre><h3 id="挂起函数"><a href="#挂起函数" class="headerlink" title="挂起函数"></a>挂起函数</h3><p>当一个函数被 suspend 修饰时表示可以被挂起，调用它会导致挂起协程，挂起函数可以和正常函数那样接受参数返回结果，但只能在协程中调用或着被其他挂起函数调用。</p><pre><code>suspend fun doSomething(){        //do something        delay(1000)    }</code></pre><p>因为delay为Kotlin封装的挂起函数，所以调用delay的函数也必须是挂起函数。</p><h3 id="协程Api"><a href="#协程Api" class="headerlink" title="协程Api"></a>协程Api</h3><p>在已有的Api中，Kotlin提供了两种方式实现协程 async/Deferred和launch/Job</p><pre><code>//async/Deferredpublic actual fun &lt;T&gt; async(    context: CoroutineContext = DefaultDispatcher,    start: CoroutineStart = CoroutineStart.DEFAULT,    parent: Job? = null,   &lt;strong&gt; block: suspend CoroutineScope.() -&gt; T&lt;/strong&gt;): Deferred&lt;T&gt; {    val newContext = newCoroutineContext(context, parent)    val coroutine = if (start.isLazy)        LazyDeferredCoroutine(newContext, block) else        DeferredCoroutine&lt;T&gt;(newContext, active = true)    coroutine.start(start, coroutine, block)    return coroutine}</code></pre><pre><code>//launch/Jobpublic expect fun launch(    context: CoroutineContext = DefaultDispatcher,    start: CoroutineStart = CoroutineStart.DEFAULT,    parent: Job? = null,   &lt;strong&gt; block: suspend CoroutineScope.() -&gt; Unit&lt;/strong&gt;): Job</code></pre><p>从源码中可以看出async和launch的参数列表中只有最后一个参数：带有 suspend 修饰的函数类型不同，async中的lambda有返回值，和Deferred的类型相同。launch中的lambda没有返回值。</p><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>两个Api的构造函数中，第一个参数为context。在android开发中比较常用的两个为UI何CommonPool。<br>UI为主线程，UI线程，只有context是UI的launch或者async的block lambda中才能更新UI<br>CommonPool为公共的线程池，在context是CommonPool的lauch或者async中的block lambda中可以异步处理耗时操作。</p><pre><code>launch(UI) {            text.setText(&quot;UI&quot;)        }async(UI) {            text.setText(&quot;UI&quot;)        }launch(CommonPool) {            delay(1000)        }async(CommonPool) {            delay(1000)        }</code></pre><h4 id="async-Deferred"><a href="#async-Deferred" class="headerlink" title="async/Deferred"></a>async/Deferred</h4><pre><code> async{            loge(message = &quot;outer start&quot;)            val inner = async{                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)                &quot;stop&quot;            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            val await = inner.await()            loge(message = &quot;outer stop&quot;)            await        }//        依次打印//        16:30:41.759 14668-14737/com.moo.demogo E/DemoGo: outer start//        16:30:41.761 14668-14737/com.moo.demogo E/DemoGo: outer wait itself start//        16:30:41.768 14668-14737/com.moo.demogo E/DemoGo: inner start//        16:30:42.268 14668-14738/com.moo.demogo E/DemoGo: outer wait itself stop//        16:30:42.268 14668-14738/com.moo.demogo E/DemoGo: outer wait inner//        16:30:42.771 14668-14738/com.moo.demogo E/DemoGo: inner stop//        16:30:42.772 14668-14738/com.moo.demogo E/DemoGo: outer stop</code></pre><p>从打印的信息可以看出outer（外层async）开始线性调用，打印outer start，在inner创建之后inner也开始执行，（outer wait itself start打印在inner start之前是因为inner async在创建的过程中会耗费极少的时间，而在这段时间内outer已经执行到下一步，理论上在inner创建之后，inner和outer之后都是同步执行）当outer等待500ms之后 outer打印outer wait itself stop同时开始等待inner，打印outer wait inner，下面这句代码val await = inner.await()为Kotlin协程重点。正常情况下，outer会直接打印outer stop，之后等待500ms之后 inner stop。但是由于inner.await(),outer会挂起，等待inner执行结束，返回字符串“stop”之后，outer再结束，这也就是为什么最后是outer wait inner500ms之后inner stop 然后才是outer stop</p><h4 id="launch-Job"><a href="#launch-Job" class="headerlink" title="launch/Job"></a>launch/Job</h4><pre><code>launch{            loge(message = &quot;outer start&quot;)            val inner = launch{                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            inner.join()            loge(message = &quot;outer stop&quot;)        }//        依次打印//        16:57:05.431 20131-20298/com.moo.demogo E/DemoGo: outer start//        16:57:05.432 20131-20298/com.moo.demogo E/DemoGo: outer wait itself start//        16:57:05.432 20131-20300/com.moo.demogo E/DemoGo: inner start//        16:57:05.940 20131-20298/com.moo.demogo E/DemoGo: outer wait itself stop//        16:57:05.940 20131-20298/com.moo.demogo E/DemoGo: outer wait inner//        16:57:06.439 20131-20298/com.moo.demogo E/DemoGo: inner stop//        16:57:06.441 20131-20300/com.moo.demogo E/DemoGo: outer stop</code></pre><p>打印信息和async/Deferred一致，区别在与lauch返回Job，挂起方法为job.join()且没有返回值。</p><p>async和launch可以根据是否需要返回值这一特点选择使用或者混合使用</p><pre><code>launch {            loge(message = &quot;outer start&quot;)            val inner = async {                loge(message = &quot;inner start&quot;)                //do something                delay(1000)                loge(message = &quot;inner stop&quot;)                &quot;stop&quot;            }            loge(message = &quot;outer wait itself start&quot;)            delay(500)            loge(message = &quot;outer wait itself stop&quot;)            loge(message = &quot;outer wait inner&quot;)            val await = inner.await()            //deal result await            loge(message = &quot;outer stop&quot;)        }</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>源码分析SwipeRefreshLayout子View侧滑冲突（侧滑菜单ListView，ViewPager）</title>
      <link href="/2018/04/25/tips-swiperefreshlayout/"/>
      <url>/2018/04/25/tips-swiperefreshlayout/</url>
      <content type="html"><![CDATA[<p>文中涉及代码都在我的<a href="https://github.com/moodstrikerdd/DemoGo" target="_blank" rel="noopener">github</a>上。如有不足之处，欢迎指正。QQ：542814693。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间项目需要侧滑菜单的ListView，所以自己重写ListView仿qq的部分效果自定义了一个SideslipListView，在Dome里面运行正常，但是在使用的时候，发现经常侧滑有时候滑一半就失灵了，并且同时触发了SwipeRefreshLayout的下拉刷新CircleImageView的显示。反复试验了几次并配合log，得出问题：<strong>当SideslipListView到了顶部且侧滑的时候出现垂直方向滑动，会导致子View的滑动事件失效，SwipeRefreshLayout处理了滑动事件，显示顶部CircleImageView。</strong>因为我的SideslipListView是通过对触摸事件做处理实现侧滑的，所以我第一反应就是可能滑动冲突了。</p><h3 id="Android事件分发"><a href="#Android事件分发" class="headerlink" title="Android事件分发"></a>Android事件分发</h3><p><img src="/2018/04/25/tips-swiperefreshlayout/timg.jpg" alt=""><br>上面这张图相信所有人都烂熟于心了，简单分析可以知道SwipeRefreshLayout可能搞事情的地方是<strong>dispatchTouchEvent ，onInterceptTouchEvent</strong>。那就去看看源码中是如何实现。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>SwipeRefreshLayout继承自ViewGroup，在SwipeRefreshLayout中没有重写dispatchTouchEvent，只重写了 onInterceptTouchEvent，所以只用看在onInterceptTouchEvent中怎么处理的。<br><pre><code>@Override   public boolean onInterceptTouchEvent(MotionEvent ev) {       ensureTarget();       final int action = ev.getActionMasked();       int pointerIndex;       if (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) {           mReturningToStart = false;       }       if (!isEnabled() || mReturningToStart || canChildScrollUp()               || mRefreshing || mNestedScrollInProgress) {           &#x2F;&#x2F; Fail fast if we&#39;re not in a state where a swipe is possible           return false;       }       switch (action) {           case MotionEvent.ACTION_DOWN:               setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCircleView.getTop());               mActivePointerId = ev.getPointerId(0);               mIsBeingDragged = false;               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               mInitialDownY = ev.getY(pointerIndex);               break;           case MotionEvent.ACTION_MOVE:               if (mActivePointerId == INVALID_POINTER) {                   Log.e(LOG_TAG, &quot;Got ACTION_MOVE event but don&#39;t have an active pointer id.&quot;);                   return false;               }               pointerIndex = ev.findPointerIndex(mActivePointerId);               if (pointerIndex &lt; 0) {                   return false;               }               final float y = ev.getY(pointerIndex);               startDragging(y);               break;           case MotionEvent.ACTION_POINTER_UP:               onSecondaryPointerUp(ev);               break;           case MotionEvent.ACTION_UP:           case MotionEvent.ACTION_CANCEL:               mIsBeingDragged = false;               mActivePointerId = INVALID_POINTER;               break;       }       return mIsBeingDragged;   }</code></pre><br>可以看到最终返回的是mIsBeingDragged的值，mIsBeingDragged表示SwipeRefreshLayout是否开始下拉刷新的操作，即SwipeRefreshLayout顶部的CircleImageView是否开始显示。mIsBeingDragged的值是true时，就会导致SwipeRefreshLayout的子View不能接受到相应的事件。</p><p>在分Action处理事件之前有一段代码</p><pre><code>if (!isEnabled() || mReturningToStart || canChildScrollUp()                || mRefreshing || mNestedScrollInProgress) {            // Fail fast if we&#39;re not in a state where a swipe is possible            return false;        }</code></pre><p>这段代码在SwipeRefreshLayout不可用，或者SwipeRefreshLayout的子View没有滑动到了顶部(其中ListView的判断是canChildScrollUp())的时候直接返回false，不拦截子view的触摸事件。这也就是为什么最开始产生的问题中，必须是SideSlipListView滑动到顶部的时候才会产生。</p><pre><code>public boolean canChildScrollUp() {    if (mChildScrollUpCallback != null) {        return mChildScrollUpCallback.canChildScrollUp(this, mTarget);    }    if (mTarget instanceof ListView) {        return ListViewCompat.canScrollList((ListView) mTarget, -1);    }    return mTarget.canScrollVertically(-1);}</code></pre><p>ACTION_DOWN ：mIsBeingDragged的第一次赋值在ACTION_DOWN中赋值为false，ACTION_DOWN中其他的代码都是初始化一些参数，可以略过。</p><p>ACTION_MOVE:在ACTION_MOVE中获取了触摸的Y坐标，然后调用了startDrag个ing（y）,跟踪过去。</p><pre><code>private void startDragging(float y) {       final float yDiff = y - mInitialDownY;       if (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) {           mInitialMotionY = mInitialDownY + mTouchSlop;           mIsBeingDragged = true;           mProgress.setAlpha(STARTING_PROGRESS_ALPHA);       }   }</code></pre><p>这里一目了然，把当前的y坐标和ACTION_DOWN中的起始y坐标求差，当Y轴的移动距离大于系统最小滑动距离的时候，会将mIsBeingDragged从false变成true,从而使onInterceptTouchEvent返回true，拦截子View的触摸事件。所以只要我们重写SwipeRefreshLayout的onInterceptTouchEvent方法，当滑动事件可判断为水平滑动的时候直接返回false，就可以解决SwipeRefreshLayout下子View的水平滑动冲突了。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code>/** * 是否让子view处理touch事件 */private boolean letChildDealTouchEvent;private float startX;private float startY;private int mTouchSlop;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) {    switch (ev.getAction()) {        case MotionEvent.ACTION_DOWN:            // 记录手指按下的位置            startY = ev.getY();            startX = ev.getX();            // 初始化标记            letChildDealTouchEvent = false;            break;        case MotionEvent.ACTION_MOVE:            // 如果子view正在拖拽中，那么不拦截它的事件，直接return false；            if (letChildDealTouchEvent) {                return false;            }            // 获取当前手指位置            float endY = ev.getY();            float endX = ev.getX();            float distanceX = Math.abs(endX - startX);            float distanceY = Math.abs(endY - startY);            // 如果X轴位移大于Y轴位移，那么将事件交给子View处理            if (distanceX &gt; mTouchSlop &amp;&amp; distanceX &gt; distanceY) {                letChildDealTouchEvent = true;                return false;            }            break;        case MotionEvent.ACTION_UP:        case MotionEvent.ACTION_CANCEL:            // 初始化标记            letChildDealTouchEvent = false;            break;        default:            break;    }    return super.onInterceptTouchEvent(ev);}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>当SwipeRefreshLayout可用且在子view滑动到顶部的时候，会对垂直方向的滑动事件做判断，当垂直方向向下的滑动距离大于系统最小滑动距离的时候，会拦截子View的Touch事件，开始做下拉刷新处理。重写SwipeRefreshLayout的onInterceptTouchEvent事件，对水平滑动做相应处理，可以避免该问题产生。 </strong></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> View </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
